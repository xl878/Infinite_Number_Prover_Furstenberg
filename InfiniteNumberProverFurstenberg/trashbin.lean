-- import Mathlib
-- import InfiniteNumberProverFurstenberg.Basic

-- open Set

-- namespace Furstenberg

-- /--
-- Part 1:
-- Arithmetic progressions on `ℤ`, and basic number-theoretic properties.

-- `arithProg a b` is the bi-infinite arithmetic progression on `ℤ`
-- given by the congruence class `x ≡ a (mod b)`, where `b : ℕ`.
-- -/

-- def arithProg (a : ℤ) (b : ℕ) : Set ℤ :=
--   { x : ℤ | Int.ModEq (b : ℤ) x a }

-- lemma mem_arithProg_iff (a : ℤ) (b : ℕ) (x : ℤ) :
--     x ∈ arithProg a b ↔ Int.ModEq (b : ℤ) x a :=
--     Iff.rfl

-- /--
-- A congruence class mod `b` is exactly the range of the map `z ↦ a + b*z`.
-- This is the “parametric form” of an arithmetic progression.
-- -/
-- lemma arithProg_eq_range (a : ℤ) (b : ℕ) :
--     arithProg a b = Set.range (fun z : ℤ => a + (b : ℤ) * z) := by
--   ext x
--   constructor
--   · intro hx
--     -- `x ≡ a (mod b)` ↔ `(b : ℤ) ∣ x - a`
--     -- hx : x ∈ arithProg a b
--     have hmod : Int.ModEq (b : ℤ) x a := by
--       simpa [arithProg] using hx

--     have hdvd : (b : ℤ) ∣ x - a := by
--       -- modEq_iff_dvd is stated for (a ≡ x), so flip if needed
--       exact (Int.modEq_iff_dvd).1 hmod.symm

--     rcases hdvd with ⟨k, hk⟩
--     refine ⟨k, ?_⟩
--     -- from `x - a = b*k` derive `x = a + b*k`
--     have := congrArg (fun t : ℤ => t + a) hk
--     -- `(x - a) + a = x`, and `(b*k) + a = a + b*k`
--     simpa [sub_eq_add_neg, add_assoc, add_left_comm, add_comm] using this.symm
--   · rintro ⟨k, rfl⟩
--     apply (Int.modEq_iff_dvd).2
--     refine ⟨-k, ?_⟩
--     -- goal: a - (a + (b:ℤ)*k) = (b:ℤ) * (-k)
--     calc
--       a - (a + (b : ℤ) * k) = -((b : ℤ) * k) := by abel
--       _ = (b : ℤ) * (-k) := by ring


-- /--
-- If `b > 0`, then `arithProg a b` is infinite.
-- -/
-- lemma infinite_arithProg (a : ℤ) {b : ℕ} (hb : 0 < b) :
--     (arithProg a b).Infinite := by
--   classical
--   -- rewrite `arithProg` as a range
--   have hr : arithProg a b = Set.range (fun z : ℤ => a + (b : ℤ) * z) :=
--     arithProg_eq_range a b

--   -- show the parametrization map is injective when `b ≠ 0` in `ℤ`
--   have hb0 : (b : ℤ) ≠ 0 := by
--     exact_mod_cast (Nat.ne_of_gt hb)

--   have hinj : Function.Injective (fun z : ℤ => a + (b : ℤ) * z) := by
--     intro z₁ z₂ h
--     have : (b : ℤ) * z₁ = (b : ℤ) * z₂ := by
--       exact add_left_cancel h
--     exact mul_left_cancel₀ hb0 this

--   -- an injective map from an infinite type gives an infinite range
--   have : (Set.range (fun z : ℤ => a + (b : ℤ) * z)).Infinite := by
--     classical
--     -- `ℤ` is infinite, and the function is injective
--     simpa using (Set.infinite_range_of_injective hinj)

--   simpa [hr] using this


-- /--
-- Part 2:
-- 1. define the Furstenberg basis (all arithmetic progressions),
-- 2. define the generated topology, and
-- 3. prove the key fact: Every arithmetic progression is open in the Furstenberg topology.

-- A wrapper type for `ℤ` used only to carry Furstenberg’s topology.

-- `FbInt := ULift ℤ` is definitionally different from `ℤ`, so a new topology can be put on it without interfering with the existing
-- topology on `ℤ`.
-- Coercions allow us to freely move between `FbInt` and `ℤ`
-- when stating arithmetic properties.
-- -/
-- def FbInt := ULift ℤ

-- instance : CoeTC FbInt ℤ := ⟨fun x => x.down⟩
-- instance : CoeTC ℤ FbInt := ⟨fun z => ⟨z⟩⟩

-- /-- Same arithmetic progression, but as a subset of `FbInt`.
-- This depends on CoeTC FbInt ℤ instance.
-- -/
-- def arithProgF (a : ℤ) (b : ℕ) : Set FbInt :=
--   { x : FbInt | Int.ModEq (b : ℤ) x.down a } -- elements carry an integer via `down`

-- /--
-- The Furstenberg basis: all congruence classes modulo a positive natural `b`.
-- These are the sets arithProgF a b (i.e., a + bℤ).
-- -/
-- def furstenbergBasis : Set (Set FbInt) :=
--   { U | ∃ (a : ℤ) (b : ℕ), 0 < b ∧ U = arithProgF a b }

-- /--
-- Furstenberg's topology on `FbInt` is the topology generated by the basis
-- `{a + bℤ | b > 0}`.
-- -/
-- def furstenbergTopology : TopologicalSpace FbInt :=
--   TopologicalSpace.generateFrom furstenbergBasis

-- instance : TopologicalSpace FbInt := furstenbergTopology
-- /--
-- In the Furstenberg topology, each arithmetic progression is open.
-- This is the fundamental “basis sets are open” lemma from `generateFrom`.
-- -/
-- lemma isOpen_arithProgF (a : ℤ) {b : ℕ} (hb : 0 < b) :
--     @IsOpen FbInt furstenbergTopology (arithProgF a b) := by
--   -- In a `generateFrom` topology, every generating set is open.
--   apply TopologicalSpace.isOpen_generateFrom_of_mem
--   -- So it suffices to show `arithProgF a b` is in the generating family.
--   refine ⟨a, b, hb, rfl⟩

-- /--Define the transport map for sets-/
-- def liftSet (S : Set ℤ) : Set FbInt :=
--   { x : FbInt | x.down ∈ S }

-- lemma mem_liftSet {S : Set ℤ} {x : FbInt} :
--     x ∈ liftSet S ↔ x.down ∈ S := by
--   rfl

-- lemma liftSet_compl (S : Set ℤ) :
--     liftSet (Sᶜ) = (liftSet S)ᶜ := by
--   ext x
--   rfl

-- lemma liftSet_iUnion {ι : Type*} (U : ι → Set ℤ) :
--     liftSet (⋃ i, U i) = ⋃ i, liftSet (U i) := by
--   ext x
--   -- expand membership in `liftSet`, then in `⋃`
--   simp [liftSet]

-- lemma liftSet_iInter {ι : Type*} (U : ι → Set ℤ) :
--     liftSet (⋂ i, U i) = ⋂ i, liftSet (U i) := by
--   ext x
--   -- expand membership in `liftSet`, then in `⋂`
--   simp [liftSet]

-- /--Connect arithProgF with arithProg-/
-- lemma arithProgF_eq_liftSet (a : ℤ) (b : ℕ) :
--     arithProgF a b = liftSet (arithProg a b) := by
--   ext x
--   rfl

-- /--
-- Part 3:
-- A residue-class partition on `ℤ`.

-- For `b > 0`, the complement of `arithProg a b` is the union of the other
-- nonzero residue classes modulo `b`, indexed by the finite type
-- `{i : Fin b // i.1 ≠ 0}`.


-- A convenient notation: the modulus as an integer. -/
-- private def bInt (b : ℕ) : ℤ := (b : ℤ)

-- /--
-- Key helper: for `m > 0`, the remainder `z % m` lies in `[0, m)`.
-- Package the two needed inequalities.
-- -/
-- private lemma emod_bounds {z m : ℤ} (hm : 0 < m) :
--     0 ≤ z % m ∧ z % m < m := by
--   constructor
--   · exact Int.emod_nonneg z (ne_of_gt hm)
--   · exact Int.emod_lt_of_pos z hm

-- /--
-- The complement of `arithProg a b` (with `b > 0`) is a union of the other
-- `b - 1` congruence classes:
-- `⋃ i ≠ 0, arithProg (a + i) b`.

-- Implement “i ≠ 0” using a subtype `{i : Fin b // i.1 ≠ 0}`.
-- -/
-- lemma arithProg_compl_eq_iUnion (a : ℤ) {b : ℕ} (hb : 0 < b) :
--     (arithProg a b)ᶜ =
--       ⋃ i : {i : Fin b // i.1 ≠ 0},
--         arithProg (a + ((i.1.1 : ℕ) : ℤ)) b := by
--   classical
--   -- abbreviations
--   let m : ℤ := bInt b
--   have hm : 0 < m := Int.ofNat_lt.mpr hb
--   have hm0 : m ≠ 0 := ne_of_gt hm

--   ext x
--   constructor

--   · -- (→) If `x ∉ arithProg a b`, pick the unique residue class of `x - a`
--     intro hx
--     have hx' : ¬ Int.ModEq m x a := by
--       -- unfold membership
--       simpa [arithProg, m] using hx

--     -- Define the remainder r = (x - a) % m
--     let r : ℤ := (x - a) % m
--     have hr_bounds : 0 ≤ r ∧ r < m := by
--       simpa [r] using emod_bounds (z := x - a) (m := m) hm
--     have hr_nonneg : 0 ≤ r := hr_bounds.1
--     have hr_lt : r < m := hr_bounds.2

--     -- Convert r to a natural number in {0, …, b-1}
--     let rn : ℕ := Int.toNat r
--     have hr_ofNat : (rn : ℤ) = r := by
--       -- `r ≥ 0` gives `ofNat (toNat r) = r`
--       simpa [rn] using (Int.toNat_of_nonneg hr_nonneg)

--     have hrn_lt : rn < b := by
--       -- from r < m = b as integers, transport to naturals
--       have : (rn : ℤ) < (b : ℤ) := by
--         -- rewrite rn as r
--         simpa [m, hr_ofNat] using hr_lt
--       -- `((rn:ℤ) < (b:ℤ)) → rn < b`
--       exact (Int.ofNat_lt).1 this

--     -- Show that r ≠ 0 (otherwise x would be congruent to a)
--     have hr_ne0 : r ≠ 0 := by
--       intro hr0
--       -- r = 0 ⇒ m ∣ (x - a)
--       have hdiv : m ∣ (x - a) := by
--         have : (x - a) % m = 0 := by simp [r, hr0]
--         exact Int.dvd_of_emod_eq_zero this
--       -- therefore x ≡ a [ZMOD m]
--       have hdiv' : m ∣ a - x := by
--         rcases hdiv with ⟨c, hc⟩
--         refine ⟨-c, ?_⟩
--         -- show: a - x = m * (-c)
--         -- from hc : x - a = m * c
--         -- negate hc and rearrange
--         have hc' : a - x = -(m * c) := by
--           -- x - a = -(a - x)
--           -- so a - x = -(x - a)
--           -- hence = -(m*c)
--           calc
--             a - x = -(x - a) := by abel
--               _ = -(m * c) := by simp [hc]
--         -- finish by rewriting -(m*c) = m*(-c)
--         simp [mul_neg, hc']

--       have hmod : Int.ModEq m x a := (Int.modEq_iff_dvd).2 hdiv'
--       exact hx' hmod

--     have hrn_ne0 : rn ≠ 0 := by
--       intro hrn0
--       -- if rn = 0 then r = 0 because r ≥ 0 and rn = toNat r
--       have : (rn : ℤ) = 0 := by simp [hrn0]
--       have : r = 0 := by simpa [hr_ofNat] using this
--       exact hr_ne0 this

--     -- Package rn as a nonzero residue i : Fin b
--     let iFin : Fin b := ⟨rn, hrn_lt⟩
--     have hiFin_ne0 : iFin.1 ≠ 0 := by
--       -- `iFin.1 = rn`
--       simpa [iFin] using hrn_ne0

--     let i : {i : Fin b // i.1 ≠ 0} := ⟨iFin, hiFin_ne0⟩

--     -- Now show x lies in the class a + rn (mod b)
--     have hx_in : x ∈ arithProg (a + (rn : ℤ)) b := by
--       -- show `Int.ModEq m x (a + rn)`
--       have hmod : Int.ModEq m x (a + r) := by
--         apply (Int.modEq_iff_dvd).2
--         -- `m ∣ x - (a+r)` because `x - (a+r) = (x-a) - r`
--         refine ⟨-((x - a) / m), ?_⟩
--         have h := Int.emod_add_mul_ediv (x - a) m
--         have h' : m * ((x - a) / m) = (x - a) - ((x - a) % m) := by
--           apply (eq_sub_iff_add_eq).2
--           simpa [add_comm, add_left_comm, add_assoc, mul_comm, mul_left_comm, mul_assoc] using h

--         -- goal: m ∣ x - (a + r); witness `-((x - a) / m)` using the Euclidean division identity.
--         calc
--           (a + r) - x
--               = -(x - (a + r)) := by abel
--           _ = -((x - a) - r) := by
--                 -- expand x - (a+r)
--                 ring_nf
--           _ = -((x - a) - ((x - a) % m)) := by
--                 simp [r]
--           _ = - (m * ((x - a) / m)) := by
--                 simp [h']
--           _ = m * ( -((x - a) / m)) := by
--                 ring_nf

--       -- replace r by rn via hr_ofNat
--       have : Int.ModEq m x (a + (rn : ℤ)) := by
--         simpa [hr_ofNat] using hmod
--       simpa [arithProg, m] using this

--     -- Conclude membership in the union
--     have : x ∈ arithProg (a + Int.ofNat i.1.1) b := by
--       -- unfold i, iFin
--       simpa [i, iFin, Int.ofNat_eq_natCast] using hx_in
--     -- show x ∈ ⋃ i, ...
--     refine Set.mem_iUnion.mpr ?_
--     refine ⟨i, ?_⟩
--     simpa [i, iFin] using hx_in


--   · -- (←) If `x` is in some other residue class, it cannot be in `arithProg a b`
--     intro hx
--     -- unpack membership in the union
--     rcases mem_iUnion.1 hx with ⟨i, hxi⟩
--     -- Suppose for contradiction that x ∈ arithProg a b
--     intro hx0
--     have hx0' : Int.ModEq m x a := by
--       simpa [arithProg, m] using hx0
--     have hxi' : Int.ModEq m x (a + Int.ofNat i.1.1) := by
--       simpa [arithProg, m] using hxi

--     -- Then (a + i) ≡ a (mod m)
--     have : Int.ModEq m (a + Int.ofNat i.1.1) a :=
--       Int.ModEq.trans (Int.ModEq.symm hxi') hx0'

--     -- Convert to divisibility: m ∣ (a+i) - a = i
--     have hdvdZ : m ∣ (a + Int.ofNat i.1.1) - a := (Int.modEq_iff_dvd).1 this.symm
--     have hdvdZ' : m ∣ (Int.ofNat i.1.1) := by
--       -- (a + i) - a = i
--       simpa [sub_eq_add_neg, add_assoc, add_left_comm, add_comm] using hdvdZ

--     -- Convert integer divisibility to nat divisibility
--     have hdvdNat : b ∣ i.1.1 := by
--       -- `m = (b:ℤ)` and `(i:ℤ)` are `Int.ofNat`
--       -- so divisibility is equivalent
--       simpa [m] using (Int.ofNat_dvd.1 hdvdZ')

--     -- But `i < b` (because i : Fin b) and `i ≠ 0`, contradiction.
--     have hlt : i.1.1 < b := i.1.2
--     have hzero : i.1.1 = 0 := Nat.eq_zero_of_dvd_of_lt hdvdNat hlt
--     exact (i.2) hzero


-- /--
-- Part 4:
-- Topological openness on `FbInt`.

-- From this point onward, the code works in the Furstenberg topology
-- `furstenbergTopology` on `FbInt`.

-- For convenience and stability, the aliases
-- `IsOpenT` and `IsClosedT` are used to denote openness and closedness
-- with respect to this topology.

-- Later, the code will show that Furstenberg openness admits a local basis
-- of arithmetic progressions, which implies infinitude of nonempty open sets.
-- -/

-- def IsOpenT  (U : Set FbInt) : Prop := IsOpen U
-- def IsClosedT (U : Set FbInt) : Prop := IsOpenT (Uᶜ)


-- lemma IsOpenT_def (U : Set FbInt) :
--     IsOpenT U = @IsOpen FbInt furstenbergTopology U := rfl

-- -- Closed = open complement, in chosen topology
-- lemma IsClosedT_iff_IsOpenT_compl (U : Set FbInt) :
--     IsClosedT U ↔ IsOpenT (Uᶜ) := by
--   rfl

-- lemma IsClosedT_iff_IsClosed (U : Set FbInt) :
--     IsClosedT U ↔ IsClosed U := by
--   dsimp [IsClosedT, IsOpenT]
--   exact (isOpen_compl_iff : IsOpen (Uᶜ) ↔ IsClosed U)

-- lemma IsClosedT_of_IsClosed (U : Set FbInt) :
--     @IsClosed FbInt furstenbergTopology U → IsClosedT U := by
--   intro h
--   -- IsClosed means: IsOpen of complement
--   -- use Mathlib lemma in the same topology
--   exact (isOpen_compl_iff.mpr h)


-- /--
-- Complement decomposition on `FbInt`.

-- This is the residue-class partition for `arithProgF a b` (with `b > 0`):
-- its complement is the union of the other nonzero residue classes mod `b`.
-- The proof transports the corresponding `ℤ` statement via `liftSet`.
-- -/

-- lemma arithProgF_compl_eq_iUnion (a : ℤ) {b : ℕ} (hb : 0 < b) :
--     (arithProgF a b)ᶜ =
--       ⋃ i : {i : Fin b // i.1 ≠ 0},
--         arithProgF (a + ((i.1.1 : ℕ) : ℤ)) b := by
--   -- Start from the residue-class decomposition on `ℤ`.
--   have hZ :
--       (arithProg a b)ᶜ =
--         ⋃ i : {i : Fin b // i.1 ≠ 0},
--           arithProg (a + ((i.1.1 : ℕ) : ℤ)) b :=
--     arithProg_compl_eq_iUnion (a := a) (b := b) hb

--   -- Apply `liftSet` to transport that equality from `ℤ`-sets to `FbInt`-sets.
--   have hLift :
--       liftSet ((arithProg a b)ᶜ) =
--         liftSet (⋃ i : {i : Fin b // i.1 ≠ 0},
--           arithProg (a + ((i.1.1 : ℕ) : ℤ)) b) :=
--     congrArg liftSet hZ

--   -- Rewrite the transported statement back into `arithProgF` form.
--   calc
--     (arithProgF a b)ᶜ
--         = liftSet ((arithProg a b)ᶜ) := by
--             ext x; rfl
--     _   = liftSet (⋃ i : {i : Fin b // i.1 ≠ 0},
--             arithProg (a + ((i.1.1 : ℕ) : ℤ)) b) := by
--             exact hLift
--     _   = ⋃ i : {i : Fin b // i.1 ≠ 0},
--             arithProgF (a + ((i.1.1 : ℕ) : ℤ)) b := by
--       -- First rewrite `liftSet (⋃ i, ...)` into `⋃ i, liftSet (...)`,
--       -- then rewrite each `liftSet (arithProg ...)` into `arithProgF ...`.
--       ext x
--       constructor
--       · intro hx
--         -- hx : x ∈ liftSet (⋃ i, arithProg ...)
--         -- Turn it into membership in the iUnion of liftSets.
--         have hx' :
--             x ∈ ⋃ i : {i : Fin b // i.1 ≠ 0},
--               liftSet (arithProg (a + ((i.1.1 : ℕ) : ℤ)) b) := by
--           -- use the lemma liftSet_iUnion specialized to this index type
--           -- (note: this is the *same* as your `hU`)
--           simpa [liftSet, Set.mem_iUnion] using hx

--         rcases Set.mem_iUnion.1 hx' with ⟨i, hi⟩
--         -- Rewrite the term set to `arithProgF`
--         refine Set.mem_iUnion.2 ⟨i, ?_⟩
--         -- `arithProgF_eq_liftSet` is definitional, so `simpa` is safe here.
--         simpa [arithProgF_eq_liftSet] using hi

--       · intro hx
--         rcases Set.mem_iUnion.1 hx with ⟨i, hi⟩
--         -- Move back to liftSet(arithProg ...)
--         have hi' :
--             x ∈ liftSet (arithProg (a + ((i.1.1 : ℕ) : ℤ)) b) := by
--           simpa [arithProgF_eq_liftSet] using hi
--         -- Build membership in the iUnion of liftSets
--         have hx' :
--             x ∈ ⋃ i : {i : Fin b // i.1 ≠ 0},
--               liftSet (arithProg (a + ((i.1.1 : ℕ) : ℤ)) b) := by
--           exact Set.mem_iUnion.2 ⟨i, hi'⟩
--         -- Turn back into membership in liftSet(⋃ i, arithProg ...)
--         simpa [liftSet, Set.mem_iUnion] using hx'


-- /--
-- Part 5:
-- Closedness and clopen sets in the Furstenberg topology on `FbInt`.

-- Using Part 4’s residue-class decomposition on `ℤ`, we show that each
-- arithmetic progression `arithProgF a b` with `b > 0` is not only open
-- (because it is a basis element) but also closed, because its complement
-- is a finite union of other basis elements.

-- Then define the set of multiples of `n` (as a subset of `FbInt`) and show:
-- if `p` is prime, the multiples of `p` form a clopen set.
-- -/

-- lemma isClosed_arithProgF (a : ℤ) {b : ℕ} (hb : 0 < b) :
--     IsClosed (arithProgF a b) := by
--   -- use: IsOpen (Sᶜ) ↔ IsClosed S
--   apply (isOpen_compl_iff).1
--   -- goal: IsOpen (arithProgF a b)ᶜ
--   -- rewrite complement as union of other progressions
--   rw [arithProgF_compl_eq_iUnion (a := a) (b := b) hb]
--   -- unions of opens are open
--   refine isOpen_iUnion ?_
--   intro i
--   exact isOpen_arithProgF (a := a + ((i.1.1 : ℕ) : ℤ)) (b := b) hb

-- def multiplesF (n : ℕ) : Set FbInt :=
--   { x : FbInt | (n : ℤ) ∣ x.down }

-- lemma multiplesF_eq_arithProgF (n : ℕ) :
--     multiplesF n = arithProgF 0 n := by
--   ext x
--   constructor
--   · intro hx
--     -- hx : (n : ℤ) ∣ x.down
--     -- want ModEq n x.down 0, which means (n : ℤ) ∣ 0 - x.down
--     apply (Int.modEq_iff_dvd).2
--     -- need to show (n : ℤ) ∣ 0 - x.down
--     rcases hx with ⟨k, hk⟩
--     -- hk : x.down = (n : ℤ) * k
--     use -k
--     calc
--       0 - x.down = -(x.down) := by ring
--       _ = -((n : ℤ) * k) := by rw [hk]
--       _ = (n : ℤ) * (-k) := by ring
--   · intro hx
--     -- hx : Int.ModEq (n : ℤ) x.down 0
--     -- want to show (n : ℤ) ∣ x.down
--     have : (n : ℤ) ∣ 0 - x.down := (Int.modEq_iff_dvd).1 hx
--     rcases this with ⟨k, hk⟩
--     -- hk : 0 - x.down = (n : ℤ) * k
--     use -k
--     calc
--       x.down = -(0 - x.down) := by ring
--       _ = -((n : ℤ) * k) := by rw [hk]
--       _ = (n : ℤ) * (-k) := by ring

-- lemma multiples_prime_clopen {p : ℕ} (hp : Nat.Prime p) :
--     IsOpenT (multiplesF p) ∧ IsClosedT (multiplesF p) := by
--   have hp0 : 0 < p := hp.pos

--   have hopen : IsOpenT (multiplesF p) := by
--     rw [multiplesF_eq_arithProgF (n := p)]
--     exact isOpen_arithProgF (a := 0) (b := p) hp0

--   have hclosed : IsClosedT (multiplesF p) := by
--     rw [multiplesF_eq_arithProgF (n := p)]
--     exact IsClosedT_of_IsClosed _ (isClosed_arithProgF (a := 0) (b := p) hp0)

--   exact ⟨hopen, hclosed⟩

-- lemma exists_prime_dvd_int
--     {z : ℤ} (hz0 : z ≠ 0) (hzpm : z ≠ 1 ∧ z ≠ -1) :
--     ∃ p : ℕ, Nat.Prime p ∧ (p : ℤ) ∣ z := by
--   classical
--   -- Work with n = z.natAbs
--   let n : ℕ := z.natAbs

--   -- If n ≤ 1, we derive a contradiction with hzpm
--   have hn_ge2 : 2 ≤ n := by
--     by_contra hlt
--     -- hlt : ¬ 2 ≤ n  ⇔ n < 2
--     have hlt' : n < 2 := Nat.lt_of_not_ge hlt
--     have : n = 0 ∨ n = 1 := by
--       have : n ≤ 1 := Nat.le_of_lt_succ hlt'
--       -- values of natAbs are ≥ 0, so ≤ 1 ⇒ 0 or 1
--       have hcase : n = 0 ∨ n = 1 := by
--         have : n = 0 ∨ n = 1 := by
--           have hz_nonneg : 0 ≤ (n : ℤ) := Int.natCast_nonneg _
--           omega
--         exact this
--       exact hcase
--     cases this with
--     | inl hn0 =>
--         -- n = 0 ⇒ z = 0
--         have : z = 0 := by
--           exact Int.natAbs_eq_zero.1 hn0
--         exact hz0 this
--     | inr hn1 =>
--         -- n = 1 ⇒ z = ±1
--         have : z.natAbs = 1 := hn1
--         have hz1 : z = 1 ∨ z = -1 := by
--           dsimp [Int.natAbs] at this
--           obtain
--           exact ⟨hz_pos, hz_neg⟩
--         exact hzpm hz1


--   -- Now use the standard ℕ lemma
--   obtain ⟨p, hp_prime, hp_dvd_n⟩ := Nat.exists_prime_and_dvd hn_ge2

--   -- Move `p ∣ n` up to ℤ and then to z itself
--   have hp_dvd_natAbsZ : (p : ℤ) ∣ (n : ℤ) := by
--     exact_mod_cast hp_dvd_n

--   -- relate `n` and `z`
--   -- `z.natAbs` is the nonnegative integer with |z| = z.natAbs as an ℤ
--   have : (p : ℤ) ∣ z := by
--     -- use the standard lemma `Int.coe_nat_dvd_left` or `Int.coe_nat_dvd_right`
--     -- together with the characterization of natAbs; you can look up:
--     -- `Int.coe_nat_dvd_left` / `Int.coe_nat_dvd_right` and
--     -- lemmas about `z.natAbs` in mathlib.
--     admit

--   exact ⟨p, hp_prime, this⟩

-- /-- A prime never divides `±1`. -/
-- lemma prime_not_dvd_pm_one {p : ℕ} (hp : Nat.Prime p) :
--     ¬ (p : ℤ) ∣ (1 : ℤ) ∧ ¬ (p : ℤ) ∣ (-1 : ℤ) := by
--   constructor
--   · intro h
--     -- `p ∣ 1` contradicts `p > 1`
--     have : (p : ℕ) ∣ 1 := by
--       exact_mod_cast h
--     exact hp.not_dvd_one this
--   · intro h
--     -- `p ∣ -1` ↔ `p ∣ 1`
--     have : (p : ℤ) ∣ (1 : ℤ) := by
--       simpa using (dvd_neg.mp h)
--     have : (p : ℕ) ∣ 1 := by
--       exact_mod_cast this
--     exact hp.not_dvd_one this


-- /--
-- Part 6:
-- The contradiction argument (topological Furstenberg proof).

-- Assume finitely many primes.
-- Let `A` be the union of the multiples of all primes (as subsets of `FbInt`).
-- Then `A` is closed (finite union of closed sets), hence `Aᶜ` is open.
-- But `Aᶜ = {±1}`, which is finite and nonempty, contradicting
-- “every nonempty open set is infinite”.
-- -/

-- theorem infinite_primes : Set.Infinite {p : ℕ | Nat.Prime p} := by
--   classical
--   -- `Set.Infinite s` is `¬ Set.Finite s`
--   intro hfin

--   -- Turn the finite set of primes into a finite index type.
--   let ι : Type := {p : ℕ // p ∈ hfin.toFinset}
--   haveI : Fintype ι := by
--     -- subtype of a finset is fintype
--     classical exact Fintype.ofFinite ι

--   -- Union of multiples of all primes in the finite list
--   let A : Set FbInt := ⋃ p : ι, multiplesF p.1

--   -- Each `multiplesF p` is closed, so the finite union is closed.
--   have hA_closed : IsClosed A := by
--     -- have: `multiples_prime_clopen`
--     -- need: membership in `hfin.toFinset` gives `Nat.Prime p`
--     -- and need: `IsClosed` of each piece, then `isClosed_iUnion` for finite index
--     refine isClosed_iUnion ?_
--     intro p
--     have hp_mem : p.1 ∈ hfin.toFinset := p.2
--     have hp_prime : Nat.Prime p.1 := by
--       -- key bridge: `mem_toFinset` for `Set.Finite`
--       -- goal: p.1 ∈ {p | Nat.Prime p}
--       have : p.1 ∈ ({p : ℕ | Nat.Prime p} : Set ℕ) := by
--         simpa [hfin.mem_toFinset] using hp_mem
--       simpa using this
--     -- from clopen, take the closed half
--     have : IsClosedT (multiplesF p.1) := (multiples_prime_clopen (p := p.1) hp_prime).2
--     -- `IsClosedT U` is `IsOpen (Uᶜ)`, so convert back to `IsClosed U`
--     exact (IsClosedT_iff_IsClosed (U := multiplesF p.1)).1 this

--   -- Therefore `Aᶜ` is open
--   have hA_open : IsOpenT (Aᶜ) := by
--     -- `IsClosed A ↔ IsOpen Aᶜ`
--     exact (isOpen_compl_iff.mpr hA_closed)

--   -- Main arithmetic fact: complement of union of prime multiples is `{±1}`.
--   have hA_compl_eq_pm1 :
--     Aᶜ = ({(⟨(1 : ℤ)⟩ : FbInt), (⟨(-1 : ℤ)⟩ : FbInt)} : Set FbInt) := by
--   classical
--   ext x
--   constructor

--   · intro hx
--     -- hx : x ∈ Aᶜ, so x ∉ A
--     have hxA : x ∉ A := hx

--     -- Let z be the underlying integer.
--     set z : ℤ := x.down

--     -- If z = 1 or z = -1 we are done (membership in the 2-point set).
--     by_cases hz1 : z = 1
--     · subst hz1
--       simp
--     by_cases hzn1 : z = -1
--     · subst hzn1
--       simp

--     -- Show z ≠ 0, because 0 is in A (divisible by every prime in the assumed finite set).
--     have hz0 : z ≠ 0 := by
--       intro hz0
--       -- pick a prime, e.g. 2, and show x ∈ multiplesF 2 ⊆ A
--       have hp2 : Nat.Prime 2 := by decide
--       have hmem2 : (2 : ℕ) ∈ hfin.toFinset := by
--         -- because `hfin` contains *all* primes
--         exact hfin.mem_toFinset.2 hp2
--       have : x ∈ A := by
--         refine Set.mem_iUnion.2 ⟨⟨2, hmem2⟩, ?_⟩
--         -- multiplesF 2 means (2:ℤ) ∣ z
--         -- but z = 0
--         simp [multiplesF, z, hz0]
--       exact hxA this

--     -- Now use “if z ≠ 0, ±1 then some prime divides z”, contradicting hx : x ∉ A.
--     rcases exists_prime_dvd_int (z := z) hz0 ⟨hz1, hzn1⟩ with ⟨p, hp, hpdvd⟩
--     have hmemP : p ∈ hfin.toFinset := hfin.mem_toFinset.2 hp
--     have : x ∈ A := by
--       refine Set.mem_iUnion.2 ⟨⟨p, hmemP⟩, ?_⟩
--       -- membership in multiplesF
--       simpa [multiplesF, z] using hpdvd
--     exact (hxA this).elim

--   · intro hx
--     -- hx : x ∈ {±1}; show x ∈ Aᶜ, i.e. x ∉ A
--     intro hxA
--     rcases (Set.mem_insert_iff.mp hx) with hx1 | hxrest
--     · -- x = 1
--       subst hx1
--       -- if x ∈ A, then x ∈ multiplesF p for some prime p, i.e. p ∣ 1, impossible
--       rcases Set.mem_iUnion.1 hxA with ⟨p, hpMul⟩
--       have hpPrime : Nat.Prime (↑p : ℕ) := by
--         -- because p.1 ∈ hfin.toFinset means p.1 is prime (Finset comes from primes)
--         -- you may already have this as: `p.property` in your construction;
--         -- if not, you can obtain it from `hfin` by:
--         have : Nat.Prime (↑p : ℕ) := by
--           -- `p.val` is a prime because it came from `{q | Nat.Prime q}`
--           -- if your `ι` was built differently, replace this line with the right extraction.
--           sorry
--         exact this
--       have : ¬ ((↑p : ℕ) : ℤ) ∣ (1 : ℤ) := (prime_not_dvd_pm_one hpPrime).1
--       have hdiv : ((↑p : ℕ) : ℤ) ∣ (1 : ℤ) := by
--         simpa [multiplesF] using hpMul
--       exact (this hdiv).elim
--     · -- x = -1
--       have hxneg1 : x = (⟨(-1 : ℤ)⟩ : FbInt) := by
--         simpa [Set.mem_singleton_iff] using hxrest
--       subst hxneg1
--       rcases Set.mem_iUnion.1 hxA with ⟨p, hpMul⟩
--       have hpPrime : Nat.Prime (↑p : ℕ) := by
--         sorry
--       have : ¬ ((↑p : ℕ) : ℤ) ∣ (-1 : ℤ) := (prime_not_dvd_pm_one hpPrime).2
--       have hdiv : ((↑p : ℕ) : ℤ) ∣ (-1 : ℤ) := by
--         simpa [multiplesF] using hpMul
--       exact (this hdiv).elim


--   -- So `{±1}` is open
--   have hopen_pm1 :
--       IsOpenT ({(⟨(1 : ℤ)⟩ : FbInt), (⟨(-1 : ℤ)⟩ : FbInt)} : Set FbInt) := by
--     simpa [hA_compl_eq_pm1] using hA_open

--   -- `{±1}` is finite and nonempty, contradiction with “nonempty open → infinite”.
--   have hfinite_pm1 :
--       ( { (⟨(1 : ℤ)⟩ : FbInt), (⟨(-1 : ℤ)⟩ : FbInt) } : Set FbInt).Finite := by
--     simp
--   have hnonempty_pm1 :
--       ¬ ({ ({ down := (1 : ℤ)} : FbInt), ({ down := (-1 : ℤ)} : FbInt) } : Set FbInt) = ∅ := by
--     intro h
--     have hx: ({ down := (1 : ℤ)} : FbInt) ∈
--       ({ ({ down := (1 : ℤ)} : FbInt), ({ down := (-1 : ℤ)} : FbInt) } : Set FbInt) := by simp
--     -- rewrite by h, then this becomes a membership in ∅
--     rw [h] at hx
--     exact hx

--   -- key topology lemma: any nonempty open set is infinite.
--   have h_open_infinite :
--       ∀ U : Set FbInt, IsOpenT U → U ≠ ∅ → U.Infinite := by
--     -- TODO: “extract an arithmetic progression neighborhood” lemma
--     sorry

--   have : ( { (⟨(1 : ℤ)⟩ : FbInt), (⟨(-1 : ℤ)⟩ : FbInt) } : Set FbInt).Infinite :=
--     h_open_infinite _ hopen_pm1 hnonempty_pm1

--   exact hfinite_pm1.not_infinite this

-- end Furstenberg



-- -- theorem infinite_primes_contradiction
-- --   (hfin : Set.Finite {p : ℕ | Prime p}) : False := by
-- --   classical

-- --   -- Define A as the union of all multiples of primes
-- --   let A : Set FbInt :=
-- --     ⋃ p : ℕ, ⋃ (_ : Prime p), arithProgF 0 p

-- --   -- A is closed (finite union of closed arithmetic progressions)
-- --   have hA_closed : IsClosed A := by
-- --     unfold A
-- --     refine isClosed_iUnion ?_
-- --     intro p
-- --     refine isClosed_iUnion ?_
-- --     intro hp
-- --     exact closed_arith_prog_fb (prime_gt_0_nat hp.property)

-- --   -- Hence the complement is open
-- --   have hA_open : IsOpen Aᶜ :=
-- --     hA_closed.isOpen_compl

-- --   -- Compute A explicitly
-- --   have hA_eq :
-- --       A = -({FbInt 1, FbInt (-1)} : Set FbInt) := by
-- --     unfold A
-- --     transfer
-- --     ext x
-- --     constructor
-- --     · intro hx
-- --       have : |x| ≠ 1 := by
-- --         intro h
-- --         have : x = 1 ∨ x = -1 := by
-- --           simpa using abs_eq (1 : ℤ) ▸ h
-- --         cases this <;> simp at hx
-- --       simp [this]
-- --     · intro hx
-- --       by_cases hx0 : x = 0
-- --       · subst hx0
-- --         simp [arith_prog_def]
-- --       · obtain ⟨p, hp, hpdvd⟩ :=
-- --           prime_divisor_exists hx0 (by simpa using hx)
-- --         have : x ∈ arith_prog 0 (nat p) := by
-- --           simpa [arith_prog_def, cong_0_iff] using hpdvd
-- --         refine mem_iUnion.2 ?_
-- --         refine ⟨nat p, ?_⟩
-- --         refine mem_iUnion.2 ?_
-- --         refine ⟨hp, this⟩

-- --   -- Rewrite the complement
-- --   have hA_compl :
-- --       Aᶜ = ({fbint 1, fbint (-1)} : Set fbint) := by
-- --     have := congrArg Set.compl hA_eq
-- --     simpa using this

-- --   -- Therefore {±1} is open
-- --   have hopen_pm1 : IsOpen ({fbint 1, fbint (-1)} : Set fbint) := by
-- --     simpa [hA_compl] using hA_open

-- --   --


-- -- -- key topology lemma: any nonempty open set is infinite.
--   -- have h_open_infinite :
--   --   ∀ U : Set FbInt, IsOpenT U → U ≠ ∅ → U.Infinite := by
--   --   intro U hU hne
--   --   classical

--   --   -- We'll use strong induction on the structure of open sets
--   --   -- The proof idea: every nonempty open set contains a basis element,
--   --   -- and every basis element is infinite

--   --   -- First, let's prove that every basis element is infinite
--     -- have basis_infinite : ∀ a b, 0 < b → (arithProgF a b).Infinite := by
--     --   intro a b hb_pos
--     --   -- move to ℤ via liftSet
--     --   rw [arithProgF_eq_liftSet]
--     --   by_contra hfin
--     --   -- if the lifted set is finite, then the original progression is finite
--     --   have hfinZ : (arithProg a b).Finite := by
--     --     refine
--     --       @Finite.of_injective _ _ _ hfin
--     --         (fun z : {x : ℤ // x ∈ arithProg a b} => (⟨z.val⟩ : FbInt)) ?inj
--     --     intro z₁ z₂ h_eq
--     --     -- z₁ z₂ are elements of the subtype {x : ℤ // x ∈ arithProg a b}
--     --     -- equality after lifting means equality of the underlying integers
--     --     have : (z₁.val : ℤ) = z₂.val := by
--     --       -- ULift ext-lemma
--     --       simpa [ULift.ext_iff] using h_eq
--     --     exact Subtype.ext this
--     --   -- but we know arithProg a b is infinite on ℤ
--     --   exact (infinite_arithProg a hb_pos) hfinZ


--   --   -- Now use induction on the open set structure
--   --   obtain ⟨x, hx⟩ : ∃ x, x ∈ U := Set.nonempty_iff_ne_empty.mpr hne

--   --   -- The key lemma: in a generateFrom topology, for any open set U and x ∈ U,
--   --   -- there exists a generating set (basis element) G with x ∈ G ⊆ U
--   --   have key : ∃ G ∈ furstenbergBasis, x ∈ G ∧ G ⊆ U := by
--   --     -- This uses the universal property of generateFrom
--   --     have : U ∈ @nhds FbInt furstenbergTopology x := by
--   --       rw [mem_nhds_iff]
--   --       exact ⟨U, Set.Subset.refl _, hU, hx⟩

--   --     -- Now extract a basis element
--   --     rw [TopologicalSpace.nhds_generateFrom] at this
--   --     simp at this
--   --     obtain ⟨t, ⟨ht_sub, ht_finite⟩, hx_mem, ht_subset⟩ := this

--   --     -- t is a finite set of basis elements, pick one containing x
--   --     have : ∃ S ∈ t, x ∈ S := by
--   --       by_contra h
--   --       push_neg at h
--   --       have : x ∉ ⋂₀ t := by
--   --         intro hcontra
--   --         obtain ⟨S, hS⟩ := Set.nonempty_of_mem_sInter hx_mem
--   --         exact h S hS (Set.mem_sInter.mp hcontra S hS)
--   --       exact this hx_mem

--   --     obtain ⟨S, hS_in, hx_in_S⟩ := this
--   --     exact ⟨S, ht_sub hS_in, hx_in_S, (Set.sInter_subset_of_mem hS_in).trans ht_subset⟩

--   --   obtain ⟨G, hG_basis, hx_in_G, hG_sub⟩ := key
--   --   obtain ⟨a, b, hb_pos, rfl⟩ := hG_basis

--   --   exact Set.Infinite.mono (basis_infinite a b hb_pos) hG_sub








--   -- -- key topology lemma: any nonempty open set is infinite.
--   -- have h_open_infinite :
--   --   ∀ U : Set FbInt, IsOpenT U → U ≠ ∅ → U.Infinite := by
--   --   intro U hU hne
--   --   classical
--   --   obtain ⟨x, hx⟩ : ∃ x, x ∈ U := Set.nonempty_iff_ne_empty.mpr hne

--   --   unfold IsOpenT furstenbergTopology at hU

--   --   -- Use the eliminator for open sets in generateFrom
--   --   revert x hx
--   --   apply hU.rec_on

--   --   -- Case 1: U is a basis element
--   --   · intro s hs x hx
--   --     obtain ⟨a, b, hb_pos, rfl⟩ := hs
--   --     rw [arithProgF_eq_liftSet]
--   --     by_contra hfin
--   --     apply (infinite_arithProg a hb_pos)
--   --     have : Finite (arithProg a b) := by
--   --       apply @Finite.of_injective _ _ _ hfin (fun z : arithProg a b => (⟨z.val⟩ : FbInt))
--   --       intro ⟨z1, _⟩ ⟨z2, _⟩ heq
--   --       simp [ULift.ext_iff] at heq
--   --       exact Subtype.ext heq
--   --     simpa using this

--   --   -- Case 2: U is a union (if one component is infinite, U is infinite)
--   --   · intro ι s _ ih x hx
--   --     obtain ⟨i, hi⟩ := hx
--   --     have : (s i).Infinite := ih i ⟨x, hi⟩ (by simp)
--   --     exact Set.Infinite.mono this (Set.subset_iUnion s i)

--   --   -- Case 3: U is an intersection (intersection of finite open sets...)
--   --   · intro s t _ _ _ ih_t x hx
--   --     exact ih_t ⟨x, hx.2⟩ (by simp)

--   -- -- key topology lemma: any nonempty open set is infinite.
--   -- have h_open_infinite :
--   --   ∀ U : Set FbInt, IsOpenT U → U ≠ ∅ → U.Infinite := by
--   --   intro U hU hne
--   --   classical
--   --   obtain ⟨x, hx⟩ : ∃ x, x ∈ U := by
--   --     by_contra h
--   --     have : U = (∅ : Set FbInt) := by
--   --       ext y
--   --       by_cases hy : y ∈ U
--   --       · have : ∃ x, x ∈ U := ⟨y, hy⟩
--   --         exact (h this).elim
--   --       · simp [hy]
--   --     exact hne this

--   --   -- U is open in the generateFrom topology, so by the definition of generated topology,
--   --   -- there exists a basis element (arithmetic progression) contained in U that contains x.

--   --   -- Unfold the generated topology structure
--   --   have hU' : IsOpen U := hU

--   --   -- Use the characterization of open sets in a generated topology:
--   --   -- U is open iff for each x ∈ U, there exists a finite intersection of basis sets containing x and contained in U
--   --   rw [TopologicalSpace.isOpen_generateFrom_iff] at hU'

--   --   -- Apply this to our point x ∈ U
--   --   obtain ⟨t, ht_sub, ht_finite, hx_inter, hinter_sub⟩ := hU' x hx

--   --   -- t is a finite set of basis elements (arithmetic progressions)
--   --   -- and x ∈ ⋂₀ t ⊆ U

--   --   -- Since t is finite and nonempty (because x ∈ ⋂₀ t), pick any element from t
--   --   have ht_nonempty : t.Nonempty := by
--   --     by_contra hempty
--   --     simp [Set.not_nonempty_iff_eq_empty] at hempty
--   --     rw [hempty] at hx_inter
--   --     simp at hx_inter

--   --   obtain ⟨S, hS_in_t⟩ := ht_nonempty

--   --   -- S is a basis element, so S = arithProgF a b for some a, b with b > 0
--   --   have hS_basis : S ∈ furstenbergBasis := ht_sub hS_in_t
--   --   obtain ⟨a, b, hb, rfl⟩ := hS_basis

--   --   -- x ∈ ⋂₀ t, so x ∈ S = arithProgF a b
--   --   have hx_in_S : x ∈ arithProgF a b := by
--   --     have : x ∈ ⋂₀ t := hx_inter
--   --     exact Set.mem_sInter.mp this S hS_in_t

--   --   -- ⋂₀ t ⊆ U, so S ⊆ U (since S ∈ t)
--   --   -- Actually, we need ⋂₀ t ⊆ U, which gives us a subset contained in U

--   --   -- The key: arithProgF a b is infinite (it corresponds to arithProg a b on ℤ)
--   --   have hS_infinite : (arithProgF a b).Infinite := by
--   --     -- Use the correspondence with arithProg on ℤ
--   --     have heq : arithProgF a b = liftSet (arithProg a b) := arithProgF_eq_liftSet a b
--   --     rw [heq]

--   --     -- arithProg a b is infinite on ℤ
--   --     have hZ_infinite : (arithProg a b).Infinite := infinite_arithProg a hb

--   --     -- liftSet preserves infiniteness
--   --     have : (liftSet (arithProg a b)).Infinite := by
--   --       intro hfin
--   --       -- If liftSet(S) is finite, then S is finite (liftSet is injective on elements)
--   --       have : (arithProg a b).Finite := by
--   --         -- From finite liftSet to finite original set
--   --         have : Finite {z : ℤ | z ∈ arithProg a b} := by
--   --           have : Finite {x : FbInt | x ∈ liftSet (arithProg a b)} := by
--   --             simpa using hfin
--   --           -- The map z ↦ ⟨z⟩ is a bijection onto the liftSet
--   --           have hbij : Function.Bijective (fun z : {z : ℤ | z ∈ arithProg a b} =>
--   --             (⟨z.val⟩ : FbInt)) := by
--   --             constructor
--   --             · intro ⟨z1, hz1⟩ ⟨z2, hz2⟩ heq
--   --               simp [ULift.ext_iff] at heq
--   --               exact Subtype.ext heq
--   --             · intro ⟨⟨y⟩⟩
--   --               simp [liftSet] at *
--   --               exact ⟨⟨y, by assumption⟩, rfl⟩
--   --           exact Finite.of_bijective hbij
--   --         simpa using this
--   --       exact hZ_infinite this
--   --     exact this

--   --   -- Since arithProgF a b is infinite and arithProgF a b ⊆ ⋂₀ t ⊆ U,
--   --   -- we have an infinite subset of U, so U is infinite
--   --   have : (⋂₀ t).Infinite := by
--   --     apply Set.Infinite.mono hS_infinite
--   --     exact Set.inter_subset_right

--   --   exact Set.Infinite.mono this hinter_sub


--   -- -- key topology lemma: any nonempty open set is infinite.
--   -- have h_open_infinite :
--   --   ∀ U : Set FbInt, IsOpenT U → U ≠ ∅ → U.Infinite := by
--   --   intro U hU hne
--   --   classical
--   --   obtain ⟨x, hx⟩ : ∃ x, x ∈ U := Set.nonempty_iff_ne_empty.mpr hne

--   --   -- Since U is open in the generated topology and x ∈ U,
--   --   -- there exists a basic open set (arithmetic progression) containing x and contained in U
--   --   rw [TopologicalSpace.isOpen_generateFrom_iff] at hU
--   --   obtain ⟨t, ht_sub, -, hx_mem, ht_subset⟩ := hU x hx

--   --   -- t is nonempty (since x ∈ ⋂₀ t)
--   --   obtain ⟨S, hS⟩ := Set.nonempty_of_mem_sInter_of_nonempty hx_mem

--   --   -- S is a basis element: S = arithProgF a b with b > 0
--   --   obtain ⟨a, b, hb_pos, rfl⟩ := ht_sub hS

--   --   -- arithProgF a b is infinite (corresponds to infinite arithProg on ℤ)
--   --   have : (arithProgF a b).Infinite := by
--   --     rw [arithProgF_eq_liftSet]
--   --     by_contra hfin
--   --     apply (infinite_arithProg a hb_pos)
--   --     have : Finite (arithProg a b) := by
--   --       apply @Finite.of_injective _ _ _ hfin (fun z : arithProg a b => (⟨z.val⟩ : FbInt))
--   --       intro ⟨z1, _⟩ ⟨z2, _⟩ heq
--   --       simp [ULift.ext_iff] at heq
--   --       exact Subtype.ext heq
--   --     simpa using this

--   --   -- arithProgF a b ⊆ ⋂₀ t ⊆ U, so U contains an infinite subset
--   --   exact Set.Infinite.mono this (Set.sInter_subset_of_mem hS |>.trans ht_subset)


-- lemma inter_arithProgF
--     (a₁ a₂ : ℤ) {b₁ b₂ : ℕ} (hb₁ : 0 < b₁) (hb₂ : 0 < b₂) :
--   ∃ a b, 0 < b ∧
--     (arithProgF a₁ b₁ ∩ arithProgF a₂ b₂ =
--       (arithProgF a b) ∨
--      arithProgF a₁ b₁ ∩ arithProgF a₂ b₂ = (∅ : Set FbInt)) := by
--   -- strategy:
--   -- 1. go down to ℤ via `arithProg` and `arithProgF_eq_liftSet`
--   -- 2. use the CRT lemma for congruences modulo b₁ and b₂
--   -- 3. transport back via `liftSet`
--   -- This part is number-theoretic and a bit long; you can
--   -- base it on `Int.ModEq` + `ZMod` CRT lemmas.
--   admit

-- -- lemma open_nonempty_infinite (U : Set FbInt)
-- --     (hU : IsOpenT U) (hne : U ≠ ∅) : U.Infinite := by
-- --   classical
-- --   obtain ⟨x, hx⟩ : Set.Nonempty U := Set.nonempty_iff_ne_empty.mpr hne

-- --   -- First prove that basis elements are infinite
-- --   have basis_infinite : ∀ a b, 0 < b → (arithProgF a b).Infinite := by
-- --     intro a b hb_pos
-- --     rw [arithProgF_eq_liftSet]
-- --     intro hfin
-- --     apply (infinite_arithProg a hb_pos)

-- --     let f : {z : ℤ | z ∈ arithProg a b} → {x : FbInt | x.down ∈ arithProg a b} :=
-- --       fun z => ⟨⟨z.val⟩, z.prop⟩

-- --     have hinj : Function.Injective f := by
-- --       intro ⟨z1, hz1⟩ ⟨z2, hz2⟩ heq
-- --       -- heq : ⟨⟨z1⟩, hz1⟩ = ⟨⟨z2⟩, hz2⟩
-- --       -- Extract that z1 = z2
-- --       have : (⟨z1⟩ : FbInt) = (⟨z2⟩ : FbInt) := by
-- --         exact congrArg Subtype.val heq
-- --       have : z1 = z2 := by
-- --         have := congrArg ULift.down this
-- --         exact this
-- --       exact Subtype.ext this

-- --     have : Finite {x : FbInt | x.down ∈ arithProg a b} := hfin
-- --     have : Finite {z : ℤ | z ∈ arithProg a b} := Finite.of_injective f hinj
-- --     exact Set.finite_coe_iff.mp this

-- --   -- Extract a basis element: in generateFrom topology,
-- --   -- open sets are unions of finite intersections of generating sets
-- --   -- For our case, just pick any generating set containing x that's in U

-- --   -- U is open means U ∈ nhds x at x
-- --   -- Use the standard fact about generateFrom
-- --   have hU_nhds : U ∈ @nhds FbInt furstenbergTopology x := IsOpen.mem_nhds hU hx

-- --   -- The key: for generateFrom topology, if U ∈ nhds x,
-- --   -- there exists a finite intersection of generators containing x inside U
-- --   -- We just need one generator
-- --   rw [TopologicalSpace.nhds_generateFrom] at hU_nhds

-- --   -- Extract existence of basis element
-- --   -- Since x is in an open set U, and opens are generated by basis,
-- --   -- there must be a basis element at x inside U
-- --   have : ∃ B ∈ furstenbergBasis, x ∈ B ∧ B ⊆ U := by
-- --     have hU_nhds : U ∈ @nhds FbInt furstenbergTopology x := IsOpen.mem_nhds hU hx
-- --     unfold furstenbergTopology at hU_nhds

-- --     obtain ⟨B, hB_basis, hxB, hB_sub⟩ :=
-- --       generateFrom_mem_nhds_basis furstenbergBasis x U hU_nhds

-- --     by_cases ht_empty : t = ∅
-- --     · use arithProgF x.down 1, ⟨x.down, 1, one_pos, rfl⟩
-- --       constructor
-- --       · -- Prove x ∈ arithProgF x.down 1
-- --         simp only [arithProgF, Set.mem_setOf_eq, Int.ModEq]

-- --       · -- Prove arithProgF x.down 1 ⊆ U
-- --         rw [ht_empty] at ht_U
-- --         simp at ht_U
-- --         rw [ht_U]
-- --         exact Set.subset_univ _

-- --     · obtain ⟨S, hS⟩ := Set.nonempty_iff_ne_empty.mpr ht_empty
-- --       use S, ht_sub hS, ht_x S hS
-- --       -- S ⊆ ⋂₀ t ⊆ U
-- --       have h1 : S ⊆ ⋂₀ t := Set.sInter_subset_of_mem hS
-- --       exact h1.trans ht_U

-- --   obtain ⟨B, hB_basis, hxB, hB_sub⟩ := this
-- --   obtain ⟨a, b, hb, rfl⟩ := hB_basis

-- --   exact (basis_infinite a b hb).mono hB_sub


--   -- have basis_infinite : ∀ a b, 0 < b → (arithProgF a b).Infinite := by
--   --   intro a b hb_pos
--   --   rw [arithProgF_eq_liftSet]
--   --   intro hfin
--   --   apply (infinite_arithProg a hb_pos)

--   --   let f : {z : ℤ | z ∈ arithProg a b} → {x : FbInt | x.down ∈ arithProg a b} :=
--   --     fun z => ⟨⟨z.val⟩, z.prop⟩

--   --   have hinj : Function.Injective f := by
--   --     intro ⟨z1, _⟩ ⟨z2, _⟩ heq
--   --     have : z1 = z2 := congrArg (fun x => x.down) (congrArg Subtype.val heq)
--   --     exact Subtype.ext this

--   --   haveI : Finite {x : FbInt | x.down ∈ arithProg a b} := hfin
--   --   have hfin_dom : Finite {z : ℤ // z ∈ arithProg a b} :=
--   --     Finite.of_injective f hinj
--   --   have hfin_set : (arithProg a b).Finite := by
--   --     simpa [Set.finite_coe_iff] using hfin_dom
--   --   exact (infinite_arithProg a hb_pos) hfin_set

--     -- have : Finite {x : FbInt | x.down ∈ arithProg a b} := hfin
--     -- have : Finite {z : ℤ | z ∈ arithProg a b} := Finite.of_injective f hinj
--     -- exact Set.finite_coe_iff.mp this


-- lemma generateFrom_mem_nhds_furstenberg (x : FbInt) (U : Set FbInt)
--     (hU : U ∈ @nhds FbInt furstenbergTopology x) :
--     ∃ V ∈ furstenbergBasis, x ∈ V ∧ V ⊆ U := by
--   obtain ⟨O, hO_sub, hO_open, hx_O⟩ := mem_nhds_iff.mp hU

--   clear hU U hO_sub
--   revert x hx_O

--   apply hO_open.rec_on
--   · -- O is a basis element
--     intros; exact ⟨_, ‹_›, ‹_›, Set.Subset.refl _⟩
--   · -- O is a union
--     intro _ _ _ IH x hx
--     obtain ⟨i, hi⟩ := Set.mem_iUnion.mp hx
--     obtain ⟨V, hVg, hxV, hVsub⟩ := IH i x hi
--     exact ⟨V, hVg, hxV, hVsub.trans (Set.subset_iUnion _ i)⟩
--   · -- O is an intersection s ∩ t
--     intro s t _ _ IHs IHt x ⟨hxs, hxt⟩
--     -- Get basis element from s
--     obtain ⟨Vs, hVs_basis, hx_Vs, hVs_sub_s⟩ := IHs x hxs
--     -- Get basis element from t
--     obtain ⟨Vt, hVt_basis, hx_Vt, hVt_sub_t⟩ := IHt x hxt
--     -- Both are arithmetic progressions, so their intersection is either empty or another progression
--     -- For now, just use Vs (we'd need to prove intersection of progressions works)
--     use Vs, hVs_basis, hx_Vs
--     -- We only have Vs ⊆ s, not Vs ⊆ s ∩ t
--     -- The intersection case is the problem!
--     sorry




-- lemma basis_infinite : ∀ a b, 0 < b → (arithProgF a b).Infinite := by
--   intro a b hb_pos
--   -- arithProgF a b = liftSet (arithProg a b)
--   rw [arithProgF_eq_liftSet]
--   -- Let hfin be a hypothetical finiteness of this lifted set
--   intro hfin
--   -- Turn finiteness of the set into finiteness of the subtype
--   have hfin_sub :
--       Finite {x : FbInt // x ∈ liftSet (arithProg a b)} :=
--     hfin.subtype

--   -- Install it as a typeclass instance for Finite.of_injective
--   haveI : Finite {x : FbInt // x ∈ liftSet (arithProg a b)} := hfin_sub

--   -- Define an injective map from the ℤ-subtype into the FbInt-subtype
--   let f :
--       {z : ℤ // z ∈ arithProg a b} →
--       {x : FbInt // x ∈ liftSet (arithProg a b)} :=
--     fun z =>
--       ⟨⟨z.1⟩, by
--         -- show (⟨z.1⟩ : FbInt) ∈ liftSet (arithProg a b)
--         -- i.e. z.1 ∈ arithProg a b, which is z.2
--         simpa [liftSet] using z.2⟩

--   have hinj : Function.Injective f := by
--     intro z₁ z₂ h
--     -- f z₁ = f z₂ ⇒ z₁.1 = z₂.1
--     have hvals : z₁.1 = z₂.1 := by
--       -- compare underlying FbInt values, then their `down`
--       have := congrArg Subtype.val h
--       -- this : (⟨z₁.1⟩ : FbInt) = ⟨z₂.1⟩
--       -- take `down` of both sides
--       have := congrArg (fun x : FbInt => x.down) this
--       simp at this
--     -- Subtype extensionality
--     exact Subtype.ext hvals

--   -- Now the *domain* subtype is finite by Finite.of_injective
--   have hfin_dom : Finite {z : ℤ // z ∈ arithProg a b} :=
--     Finite.of_injective f hinj

--   -- Convert that to finiteness of the set `arithProg a b` itself
--   have hfin_set : (arithProg a b).Finite := by
--     -- Standard equivalence:
--     -- Set.finite_coe_iff :
--     --   (arithProg a b).Finite ↔ Finite {z : ℤ // z ∈ arithProg a b}
--     simpa [Set.finite_coe_iff] using hfin_dom

--   -- But we already know arithProg a b is infinite (hb_pos > 0)
--   exact (infinite_arithProg a hb_pos) hfin_set
