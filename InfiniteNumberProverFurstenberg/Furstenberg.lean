import Mathlib
import InfiniteNumberProverFurstenberg.Basic
import Mathlib.Data.Int.ModEq
import Mathlib.Data.Set.Infinite


/--
Part 1: the arithmetic progression set on ℤ, plus the lemma that it is infinite when the step is positive.
-/

open Set

namespace Furstenberg

/--
`arithProg a b` is the bi-infinite arithmetic progression on `ℤ`
given by the congruence class `x ≡ a (mod b)`, where `b : ℕ`.
-/
def arithProg (a : ℤ) (b : ℕ) : Set ℤ :=
  { x : ℤ | Int.ModEq (b : ℤ) x a }

lemma mem_arithProg_iff (a : ℤ) (b : ℕ) (x : ℤ) :
    x ∈ arithProg a b ↔ Int.ModEq (b : ℤ) x a := Iff.rfl

/--
A congruence class mod `b` is exactly the range of the map `z ↦ a + b*z`.
This is the “parametric form” of an arithmetic progression.
-/
lemma arithProg_eq_range (a : ℤ) (b : ℕ) :
    arithProg a b = Set.range (fun z : ℤ => a + (b : ℤ) * z) := by
  ext x
  constructor
  · intro hx
    -- `x ≡ a (mod b)` ↔ `(b : ℤ) ∣ x - a`
    have hdvd : (b : ℤ) ∣ x - a := (Int.modEq_iff_dvd).1 hx
    rcases hdvd with ⟨k, hk⟩
    refine ⟨k, ?_⟩
    -- from `x - a = b*k` derive `x = a + b*k`
    have := congrArg (fun t : ℤ => t + a) hk
    -- `(x - a) + a = x`, and `(b*k) + a = a + b*k`
    simpa [sub_eq_add_neg, add_assoc, add_left_comm, add_comm] using this
  · rintro ⟨k, rfl⟩
    -- show `a + b*k ≡ a (mod b)` using the divisibility characterization
    apply (Int.modEq_iff_dvd).2
    refine ⟨k, ?_⟩
    -- `(a + b*k) - a = b*k`
    simp [sub_eq_add_neg, add_assoc, add_left_comm, add_comm]

/--
If `b > 0`, then `arithProg a b` is infinite.
-/
lemma infinite_arithProg (a : ℤ) {b : ℕ} (hb : 0 < b) :
    (arithProg a b).Infinite := by
  classical
  -- rewrite `arithProg` as a range
  have hr : arithProg a b = Set.range (fun z : ℤ => a + (b : ℤ) * z) :=
    arithProg_eq_range a b

  -- show the parametrization map is injective when `b ≠ 0` in `ℤ`
  have hb0 : (b : ℤ) ≠ 0 := by
    exact_mod_cast (Nat.ne_of_gt hb)

  have hinj : Function.Injective (fun z : ℤ => a + (b : ℤ) * z) := by
    intro z₁ z₂ h
    have : (b : ℤ) * z₁ = (b : ℤ) * z₂ := by
      exact add_left_cancel h
    exact mul_left_cancel₀ hb0 this

  -- an injective map from an infinite type gives an infinite range
  have : (Set.range (fun z : ℤ => a + (b : ℤ) * z)).Infinite :=
    Set.infinite_range_of_injective _ hinj

  simpa [hr] using this

end Furstenberg





/--
Part2:
1. define the Furstenberg basis (all arithmetic progressions),
2. define the generated topology,
3. and prove the key fact: Every arithmetic progression is open in the Furstenberg topology.
-/

import Mathlib.Topology.Basic
import Mathlib.Data.Int.ModEq

open Set

namespace Furstenberg

/-- The bi-infinite arithmetic progression (congruence class) on `ℤ`. -/
def arithProg (a : ℤ) (b : ℕ) : Set ℤ :=
  { x : ℤ | Int.ModEq (b : ℤ) x a }

/--
A type synonym for `ℤ`, so Furstenberg's topology can be put on it
without interfering with any existing topology on `ℤ`.
-/
def FbInt := ℤ

/-- Coercion is definitional: `FbInt` is just `ℤ`. -/
instance : Coe FbInt ℤ := ⟨id⟩

/--
The Furstenberg basis: all congruence classes modulo a positive natural `b`.
These are the sets `a + bℤ`.
-/
def furstenbergBasis : Set (Set FbInt) :=
  { U | ∃ (a : ℤ) (b : ℕ), 0 < b ∧ U = (arithProg a b) }

/--
Furstenberg's topology on `FbInt` is the topology generated by the basis
`{a + bℤ | b > 0}`.
-/
def furstenbergTopology : TopologicalSpace FbInt :=
  TopologicalSpace.generateFrom furstenbergBasis

/--
In the Furstenberg topology, each arithmetic progression is open.
This is the fundamental “basis sets are open” lemma from `generateFrom`.
-/
lemma isOpen_arithProg (a : ℤ) {b : ℕ} (hb : 0 < b) :
    @IsOpen FbInt furstenbergTopology (arithProg a b) := by
  -- In a `generateFrom` topology, every generating set is open.
  apply TopologicalSpace.isOpen_generateFrom_of_mem
  -- So it suffices to show `arithProg a b` is in the generating family.
  refine ⟨a, b, hb, rfl⟩

end Furstenberg
