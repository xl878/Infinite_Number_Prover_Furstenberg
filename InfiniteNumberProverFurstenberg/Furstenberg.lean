import Mathlib
import InfiniteNumberProverFurstenberg.Basic

open Set

namespace Furstenberg

/--
Part 1:
Arithmetic progressions on `ℤ`, and basic number-theoretic properties.

`arithProg a b` is the bi-infinite arithmetic progression on `ℤ`
given by the congruence class `x ≡ a (mod b)`, where `b : ℕ`.
-/

def arithProg (a : ℤ) (b : ℕ) : Set ℤ :=
  { x : ℤ | Int.ModEq (b : ℤ) x a }

lemma mem_arithProg_iff (a : ℤ) (b : ℕ) (x : ℤ) :
    x ∈ arithProg a b ↔ Int.ModEq (b : ℤ) x a :=
    Iff.rfl

/--
A congruence class mod `b` is exactly the range of the map `z ↦ a + b*z`.
This is the “parametric form” of an arithmetic progression.
-/
lemma arithProg_eq_range (a : ℤ) (b : ℕ) :
    arithProg a b = Set.range (fun z : ℤ => a + (b : ℤ) * z) := by
  ext x
  constructor
  · intro hx
    -- `x ≡ a (mod b)` ↔ `(b : ℤ) ∣ x - a`
    -- hx : x ∈ arithProg a b
    have hmod : Int.ModEq (b : ℤ) x a := by
      simpa [arithProg] using hx

    have hdvd : (b : ℤ) ∣ x - a := by
      -- modEq_iff_dvd is stated for (a ≡ x), so flip if needed
      exact (Int.modEq_iff_dvd).1 hmod.symm

    rcases hdvd with ⟨k, hk⟩
    refine ⟨k, ?_⟩
    -- from `x - a = b*k` derive `x = a + b*k`
    have := congrArg (fun t : ℤ => t + a) hk
    -- `(x - a) + a = x`, and `(b*k) + a = a + b*k`
    simpa [sub_eq_add_neg, add_assoc, add_left_comm, add_comm] using this.symm
  · rintro ⟨k, rfl⟩
    apply (Int.modEq_iff_dvd).2
    refine ⟨-k, ?_⟩
    -- goal: a - (a + (b:ℤ)*k) = (b:ℤ) * (-k)
    calc
      a - (a + (b : ℤ) * k) = -((b : ℤ) * k) := by abel
      _ = (b : ℤ) * (-k) := by ring


/--
If `b > 0`, then `arithProg a b` is infinite.
-/
lemma infinite_arithProg (a : ℤ) {b : ℕ} (hb : 0 < b) :
    (arithProg a b).Infinite := by
  classical
  -- rewrite `arithProg` as a range
  have hr : arithProg a b = Set.range (fun z : ℤ => a + (b : ℤ) * z) :=
    arithProg_eq_range a b

  -- show the parametrization map is injective when `b ≠ 0` in `ℤ`
  have hb0 : (b : ℤ) ≠ 0 := by
    exact_mod_cast (Nat.ne_of_gt hb)

  have hinj : Function.Injective (fun z : ℤ => a + (b : ℤ) * z) := by
    intro z₁ z₂ h
    have : (b : ℤ) * z₁ = (b : ℤ) * z₂ := by
      exact add_left_cancel h
    exact mul_left_cancel₀ hb0 this

  -- an injective map from an infinite type gives an infinite range
  have : (Set.range (fun z : ℤ => a + (b : ℤ) * z)).Infinite := by
    classical
    -- `ℤ` is infinite, and the function is injective
    simpa using (Set.infinite_range_of_injective hinj)

  simpa [hr] using this


/--
Part 2:
1. define the Furstenberg basis (all arithmetic progressions),
2. define the generated topology, and
3. prove the key fact: Every arithmetic progression is open in the Furstenberg topology.

A wrapper type for `ℤ` used only to carry Furstenberg’s topology.

`FbInt := ULift ℤ` is definitionally different from `ℤ`, so a new topology can be put on it without interfering with the existing
topology on `ℤ`.
Coercions allow freely move between `FbInt` and `ℤ`
when stating arithmetic properties.
-/
def FbInt := ULift.{0} ℤ

instance : CoeTC FbInt ℤ := ⟨fun x => x.down⟩
instance : CoeTC ℤ FbInt := ⟨fun z => ⟨z⟩⟩

/-- Same arithmetic progression, but as a subset of `FbInt`.
This depends on CoeTC FbInt ℤ instance.
-/
def arithProgF (a : ℤ) (b : ℕ) : Set FbInt :=
  { x : FbInt | Int.ModEq (b : ℤ) x.down a } -- elements carry an integer via `down`

/--
The Furstenberg basis: all congruence classes modulo a positive natural `b`.
These are the sets arithProgF a b (i.e., a + bℤ).
-/
def furstenbergBasis : Set (Set FbInt) :=
  { U | ∃ (a : ℤ) (b : ℕ), 0 < b ∧ U = arithProgF a b }

/--
Furstenberg's topology on `FbInt` is the topology generated by the basis
`{a + bℤ | b > 0}`.
-/
def furstenbergTopology : TopologicalSpace FbInt :=
  TopologicalSpace.generateFrom furstenbergBasis

instance : TopologicalSpace FbInt := furstenbergTopology
/--
In the Furstenberg topology, each arithmetic progression is open.
This is the fundamental “basis sets are open” lemma from `generateFrom`.
-/
lemma isOpen_arithProgF (a : ℤ) {b : ℕ} (hb : 0 < b) :
    @IsOpen FbInt furstenbergTopology (arithProgF a b) := by
  -- In a `generateFrom` topology, every generating set is open.
  apply TopologicalSpace.isOpen_generateFrom_of_mem
  -- So it suffices to show `arithProgF a b` is in the generating family.
  refine ⟨a, b, hb, rfl⟩

/--Define the transport map for sets-/
def liftSet (S : Set ℤ) : Set FbInt :=
  { x : FbInt | x.down ∈ S }

lemma mem_liftSet {S : Set ℤ} {x : FbInt} :
    x ∈ liftSet S ↔ x.down ∈ S := by
  rfl

lemma liftSet_compl (S : Set ℤ) :
    liftSet (Sᶜ) = (liftSet S)ᶜ := by
  ext x
  rfl

lemma liftSet_iUnion {ι : Type*} (U : ι → Set ℤ) :
    liftSet (⋃ i, U i) = ⋃ i, liftSet (U i) := by
  ext x
  -- expand membership in `liftSet`, then in `⋃`
  simp [liftSet]

lemma liftSet_iInter {ι : Type*} (U : ι → Set ℤ) :
    liftSet (⋂ i, U i) = ⋂ i, liftSet (U i) := by
  ext x
  -- expand membership in `liftSet`, then in `⋂`
  simp [liftSet]

/--Connect arithProgF with arithProg-/
lemma arithProgF_eq_liftSet (a : ℤ) (b : ℕ) :
    arithProgF a b = liftSet (arithProg a b) := by
  ext x
  rfl

/--
Part 3:
A residue-class partition on `ℤ`.

For `b > 0`, the complement of `arithProg a b` is the union of the other
nonzero residue classes modulo `b`, indexed by the finite type
`{i : Fin b // i.1 ≠ 0}`.


A convenient notation: the modulus as an integer. -/
private def bInt (b : ℕ) : ℤ := (b : ℤ)

/--
Key helper: for `m > 0`, the remainder `z % m` lies in `[0, m)`.
Package the two needed inequalities.
-/
private lemma emod_bounds {z m : ℤ} (hm : 0 < m) :
    0 ≤ z % m ∧ z % m < m := by
  constructor
  · exact Int.emod_nonneg z (ne_of_gt hm)
  · exact Int.emod_lt_of_pos z hm

/--
The complement of `arithProg a b` (with `b > 0`) is a union of the other
`b - 1` congruence classes:
`⋃ i ≠ 0, arithProg (a + i) b`.

Implement “i ≠ 0” using a subtype `{i : Fin b // i.1 ≠ 0}`.
-/
lemma arithProg_compl_eq_iUnion (a : ℤ) {b : ℕ} (hb : 0 < b) :
    (arithProg a b)ᶜ =
      ⋃ i : {i : Fin b // i.1 ≠ 0},
        arithProg (a + ((i.1.1 : ℕ) : ℤ)) b := by
  classical
  -- abbreviations
  let m : ℤ := bInt b
  have hm : 0 < m := Int.ofNat_lt.mpr hb
  have hm0 : m ≠ 0 := ne_of_gt hm

  ext x
  constructor

  · -- (→) If `x ∉ arithProg a b`, pick the unique residue class of `x - a`
    intro hx
    have hx' : ¬ Int.ModEq m x a := by
      -- unfold membership
      simpa [arithProg, m] using hx

    -- Define the remainder r = (x - a) % m
    let r : ℤ := (x - a) % m
    have hr_bounds : 0 ≤ r ∧ r < m := by
      simpa [r] using emod_bounds (z := x - a) (m := m) hm
    have hr_nonneg : 0 ≤ r := hr_bounds.1
    have hr_lt : r < m := hr_bounds.2

    -- Convert r to a natural number in {0, …, b-1}
    let rn : ℕ := Int.toNat r
    have hr_ofNat : (rn : ℤ) = r := by
      -- `r ≥ 0` gives `ofNat (toNat r) = r`
      simpa [rn] using (Int.toNat_of_nonneg hr_nonneg)

    have hrn_lt : rn < b := by
      -- from r < m = b as integers, transport to naturals
      have : (rn : ℤ) < (b : ℤ) := by
        -- rewrite rn as r
        simpa [m, hr_ofNat] using hr_lt
      -- `((rn:ℤ) < (b:ℤ)) → rn < b`
      exact (Int.ofNat_lt).1 this

    -- Show that r ≠ 0 (otherwise x would be congruent to a)
    have hr_ne0 : r ≠ 0 := by
      intro hr0
      -- r = 0 ⇒ m ∣ (x - a)
      have hdiv : m ∣ (x - a) := by
        have : (x - a) % m = 0 := by simp [r, hr0]
        exact Int.dvd_of_emod_eq_zero this
      -- therefore x ≡ a [ZMOD m]
      have hdiv' : m ∣ a - x := by
        rcases hdiv with ⟨c, hc⟩
        refine ⟨-c, ?_⟩
        -- show: a - x = m * (-c)
        -- from hc : x - a = m * c
        -- negate hc and rearrange
        have hc' : a - x = -(m * c) := by
          -- x - a = -(a - x)
          -- so a - x = -(x - a)
          -- hence = -(m*c)
          calc
            a - x = -(x - a) := by abel
              _ = -(m * c) := by simp [hc]
        -- finish by rewriting -(m*c) = m*(-c)
        simp [mul_neg, hc']

      have hmod : Int.ModEq m x a := (Int.modEq_iff_dvd).2 hdiv'
      exact hx' hmod

    have hrn_ne0 : rn ≠ 0 := by
      intro hrn0
      -- if rn = 0 then r = 0 because r ≥ 0 and rn = toNat r
      have : (rn : ℤ) = 0 := by simp [hrn0]
      have : r = 0 := by simpa [hr_ofNat] using this
      exact hr_ne0 this

    -- Package rn as a nonzero residue i : Fin b
    let iFin : Fin b := ⟨rn, hrn_lt⟩
    have hiFin_ne0 : iFin.1 ≠ 0 := by
      -- `iFin.1 = rn`
      simpa [iFin] using hrn_ne0

    let i : {i : Fin b // i.1 ≠ 0} := ⟨iFin, hiFin_ne0⟩

    -- Now show x lies in the class a + rn (mod b)
    have hx_in : x ∈ arithProg (a + (rn : ℤ)) b := by
      -- show `Int.ModEq m x (a + rn)`
      have hmod : Int.ModEq m x (a + r) := by
        apply (Int.modEq_iff_dvd).2
        -- `m ∣ x - (a+r)` because `x - (a+r) = (x-a) - r`
        refine ⟨-((x - a) / m), ?_⟩
        have h := Int.emod_add_mul_ediv (x - a) m
        have h' : m * ((x - a) / m) = (x - a) - ((x - a) % m) := by
          apply (eq_sub_iff_add_eq).2
          simpa [add_comm, add_left_comm, add_assoc, mul_comm, mul_left_comm, mul_assoc] using h

        -- goal: m ∣ x - (a + r); witness `-((x - a) / m)` using the Euclidean division identity.
        calc
          (a + r) - x
              = -(x - (a + r)) := by abel
          _ = -((x - a) - r) := by
                -- expand x - (a+r)
                ring_nf
          _ = -((x - a) - ((x - a) % m)) := by
                simp [r]
          _ = - (m * ((x - a) / m)) := by
                simp [h']
          _ = m * ( -((x - a) / m)) := by
                ring_nf

      -- replace r by rn via hr_ofNat
      have : Int.ModEq m x (a + (rn : ℤ)) := by
        simpa [hr_ofNat] using hmod
      simpa [arithProg, m] using this

    -- Conclude membership in the union
    have : x ∈ arithProg (a + Int.ofNat i.1.1) b := by
      -- unfold i, iFin
      simpa [i, iFin, Int.ofNat_eq_natCast] using hx_in
    -- show x ∈ ⋃ i, ...
    refine Set.mem_iUnion.mpr ?_
    refine ⟨i, ?_⟩
    simpa [i, iFin] using hx_in


  · -- (←) If `x` is in some other residue class, it cannot be in `arithProg a b`
    intro hx
    -- unpack membership in the union
    rcases mem_iUnion.1 hx with ⟨i, hxi⟩
    -- Suppose for contradiction that x ∈ arithProg a b
    intro hx0
    have hx0' : Int.ModEq m x a := by
      simpa [arithProg, m] using hx0
    have hxi' : Int.ModEq m x (a + Int.ofNat i.1.1) := by
      simpa [arithProg, m] using hxi

    -- Then (a + i) ≡ a (mod m)
    have : Int.ModEq m (a + Int.ofNat i.1.1) a :=
      Int.ModEq.trans (Int.ModEq.symm hxi') hx0'

    -- Convert to divisibility: m ∣ (a+i) - a = i
    have hdvdZ : m ∣ (a + Int.ofNat i.1.1) - a := (Int.modEq_iff_dvd).1 this.symm
    have hdvdZ' : m ∣ (Int.ofNat i.1.1) := by
      -- (a + i) - a = i
      simpa [sub_eq_add_neg, add_assoc, add_left_comm, add_comm] using hdvdZ

    -- Convert integer divisibility to nat divisibility
    have hdvdNat : b ∣ i.1.1 := by
      -- `m = (b:ℤ)` and `(i:ℤ)` are `Int.ofNat`
      -- so divisibility is equivalent
      simpa [m] using (Int.ofNat_dvd.1 hdvdZ')

    -- But `i < b` (because i : Fin b) and `i ≠ 0`, contradiction.
    have hlt : i.1.1 < b := i.1.2
    have hzero : i.1.1 = 0 := Nat.eq_zero_of_dvd_of_lt hdvdNat hlt
    exact (i.2) hzero


/--
Part 4:
Topological openness on `FbInt`.

From this point onward, the code works in the Furstenberg topology
`furstenbergTopology` on `FbInt`.

For convenience and stability, the aliases
`IsOpenT` and `IsClosedT` are used to denote openness and closedness
with respect to this topology.

Later, the code will show that Furstenberg openness admits a local basis
of arithmetic progressions, which implies infinitude of nonempty open sets.
-/

def IsOpenT  (U : Set FbInt) : Prop := IsOpen U
def IsClosedT (U : Set FbInt) : Prop := IsOpenT (Uᶜ)


lemma IsOpenT_def (U : Set FbInt) :
    IsOpenT U = @IsOpen FbInt furstenbergTopology U := rfl

-- Closed = open complement, in chosen topology
lemma IsClosedT_iff_IsOpenT_compl (U : Set FbInt) :
    IsClosedT U ↔ IsOpenT (Uᶜ) := by
  rfl

lemma IsClosedT_iff_IsClosed (U : Set FbInt) :
    IsClosedT U ↔ IsClosed U := by
  dsimp [IsClosedT, IsOpenT]
  exact (isOpen_compl_iff : IsOpen (Uᶜ) ↔ IsClosed U)

lemma IsClosedT_of_IsClosed (U : Set FbInt) :
    @IsClosed FbInt furstenbergTopology U → IsClosedT U := by
  intro h
  -- IsClosed means: IsOpen of complement
  -- use Mathlib lemma in the same topology
  exact (isOpen_compl_iff.mpr h)


/--
Complement decomposition on `FbInt`.

This is the residue-class partition for `arithProgF a b` (with `b > 0`):
its complement is the union of the other nonzero residue classes mod `b`.
The proof transports the corresponding `ℤ` statement via `liftSet`.
-/

lemma arithProgF_compl_eq_iUnion (a : ℤ) {b : ℕ} (hb : 0 < b) :
    (arithProgF a b)ᶜ =
      ⋃ i : {i : Fin b // i.1 ≠ 0},
        arithProgF (a + ((i.1.1 : ℕ) : ℤ)) b := by
  -- Start from the residue-class decomposition on `ℤ`.
  have hZ :
      (arithProg a b)ᶜ =
        ⋃ i : {i : Fin b // i.1 ≠ 0},
          arithProg (a + ((i.1.1 : ℕ) : ℤ)) b :=
    arithProg_compl_eq_iUnion (a := a) (b := b) hb

  -- Apply `liftSet` to transport that equality from `ℤ`-sets to `FbInt`-sets.
  have hLift :
      liftSet ((arithProg a b)ᶜ) =
        liftSet (⋃ i : {i : Fin b // i.1 ≠ 0},
          arithProg (a + ((i.1.1 : ℕ) : ℤ)) b) :=
    congrArg liftSet hZ

  -- Rewrite the transported statement back into `arithProgF` form.
  calc
    (arithProgF a b)ᶜ
        = liftSet ((arithProg a b)ᶜ) := by
            ext x; rfl
    _   = liftSet (⋃ i : {i : Fin b // i.1 ≠ 0},
            arithProg (a + ((i.1.1 : ℕ) : ℤ)) b) := by
            exact hLift
    _   = ⋃ i : {i : Fin b // i.1 ≠ 0},
            arithProgF (a + ((i.1.1 : ℕ) : ℤ)) b := by
      -- First rewrite `liftSet (⋃ i, ...)` into `⋃ i, liftSet (...)`,
      -- then rewrite each `liftSet (arithProg ...)` into `arithProgF ...`.
      ext x
      constructor
      · intro hx
        -- hx : x ∈ liftSet (⋃ i, arithProg ...)
        -- Turn it into membership in the iUnion of liftSets.
        have hx' :
            x ∈ ⋃ i : {i : Fin b // i.1 ≠ 0},
              liftSet (arithProg (a + ((i.1.1 : ℕ) : ℤ)) b) := by
          -- use the lemma liftSet_iUnion specialized to this index type
          -- (note: this is the *same* as `hU`)
          simpa [liftSet, Set.mem_iUnion] using hx

        rcases Set.mem_iUnion.1 hx' with ⟨i, hi⟩
        -- Rewrite the term set to `arithProgF`
        refine Set.mem_iUnion.2 ⟨i, ?_⟩
        -- `arithProgF_eq_liftSet` is definitional, so `simpa` is safe here.
        simpa [arithProgF_eq_liftSet] using hi

      · intro hx
        rcases Set.mem_iUnion.1 hx with ⟨i, hi⟩
        -- Move back to liftSet(arithProg ...)
        have hi' :
            x ∈ liftSet (arithProg (a + ((i.1.1 : ℕ) : ℤ)) b) := by
          simpa [arithProgF_eq_liftSet] using hi
        -- Build membership in the iUnion of liftSets
        have hx' :
            x ∈ ⋃ i : {i : Fin b // i.1 ≠ 0},
              liftSet (arithProg (a + ((i.1.1 : ℕ) : ℤ)) b) := by
          exact Set.mem_iUnion.2 ⟨i, hi'⟩
        -- Turn back into membership in liftSet(⋃ i, arithProg ...)
        simpa [liftSet, Set.mem_iUnion] using hx'


/--
Part 5:
Closedness and clopen sets in the Furstenberg topology on `FbInt`.

Using Part 4’s residue-class decomposition on `ℤ` to show that each
arithmetic progression `arithProgF a b` with `b > 0` is not only open
(because it is a basis element) but also closed, because its complement
is a finite union of other basis elements.

Then define the set of multiples of `n` (as a subset of `FbInt`) and show:
if `p` is prime, the multiples of `p` form a clopen set.
-/

lemma isClosed_arithProgF (a : ℤ) {b : ℕ} (hb : 0 < b) :
    IsClosed (arithProgF a b) := by
  -- use: IsOpen (Sᶜ) ↔ IsClosed S
  apply (isOpen_compl_iff).1
  -- goal: IsOpen (arithProgF a b)ᶜ
  -- rewrite complement as union of other progressions
  rw [arithProgF_compl_eq_iUnion (a := a) (b := b) hb]
  -- unions of opens are open
  refine isOpen_iUnion ?_
  intro i
  exact isOpen_arithProgF (a := a + ((i.1.1 : ℕ) : ℤ)) (b := b) hb

def multiplesF (n : ℕ) : Set FbInt :=
  { x : FbInt | (n : ℤ) ∣ x.down }

lemma multiplesF_eq_arithProgF (n : ℕ) :
    multiplesF n = arithProgF 0 n := by
  ext x
  constructor
  · intro hx
    -- hx : (n : ℤ) ∣ x.down
    -- want ModEq n x.down 0, which means (n : ℤ) ∣ 0 - x.down
    apply (Int.modEq_iff_dvd).2
    -- need to show (n : ℤ) ∣ 0 - x.down
    rcases hx with ⟨k, hk⟩
    -- hk : x.down = (n : ℤ) * k
    use -k
    calc
      0 - x.down = -(x.down) := by ring
      _ = -((n : ℤ) * k) := by rw [hk]
      _ = (n : ℤ) * (-k) := by ring
  · intro hx
    -- hx : Int.ModEq (n : ℤ) x.down 0
    -- want to show (n : ℤ) ∣ x.down
    have : (n : ℤ) ∣ 0 - x.down := (Int.modEq_iff_dvd).1 hx
    rcases this with ⟨k, hk⟩
    -- hk : 0 - x.down = (n : ℤ) * k
    use -k
    calc
      x.down = -(0 - x.down) := by ring
      _ = -((n : ℤ) * k) := by rw [hk]
      _ = (n : ℤ) * (-k) := by ring

lemma multiples_prime_clopen {p : ℕ} (hp : Nat.Prime p) :
    IsOpenT (multiplesF p) ∧ IsClosedT (multiplesF p) := by
  have hp0 : 0 < p := hp.pos

  have hopen : IsOpenT (multiplesF p) := by
    rw [multiplesF_eq_arithProgF (n := p)]
    exact isOpen_arithProgF (a := 0) (b := p) hp0

  have hclosed : IsClosedT (multiplesF p) := by
    rw [multiplesF_eq_arithProgF (n := p)]
    exact IsClosedT_of_IsClosed _ (isClosed_arithProgF (a := 0) (b := p) hp0)

  exact ⟨hopen, hclosed⟩

lemma natAbs_eq_one_iff (z : ℤ) :
    z.natAbs = 1 ↔ z = 1 ∨ z = -1 := by
  constructor
  · intro hz
    -- Case split on z
    cases z with
    | ofNat n =>
        -- z = (n : ℤ)
        -- natAbs (ofNat n) = n
        have : n = 1 := by
          simpa [Int.natAbs] using hz
        left
        -- now z = 1
        simp [this]  -- z = (1 : ℤ)
    | negSucc a =>
        -- z = -[a+1], and natAbs (negSucc a) = a.succ
        have : a.succ = 1 := by
          simpa [Int.natAbs] using hz
        -- a.succ = 1 ⇒ a = 0
        have hzero : a = 0 := by
          have : a.succ = Nat.succ 0 := by
            simpa [Nat.succ_eq_add_one] using this
          exact Nat.succ.inj this
        right
        -- Int.negSucc 0 is definitionally -1, so this closes the case
        simp [hzero]
  · intro hz
    cases hz with
    | inl hz1 =>
        -- z = 1 ⇒ natAbs z = 1
        simp [hz1]
    | inr hzneg1 =>
        -- z = -1 ⇒ natAbs z = 1
        simp [hzneg1]

lemma eq_natAbs_or_neg_natAbs (z : ℤ) :
    z = z.natAbs ∨ z = - (z.natAbs : ℤ) := by
  -- Do case split on the construction of an integer.
  cases z using Int.casesOn with
  | ofNat n =>
      -- z = ofNat n, natAbs z = n
      left
      simp [Int.natAbs]   -- gives z = z.natAbs

  | negSucc n =>
  right
  calc
    Int.negSucc n
        = -((n.succ : ℕ) : ℤ) := by
            rfl
    _   = (-1 : ℤ) + (-(n : ℤ)) := by
            -- no abel, no simpa
            simp [Nat.cast_succ, add_comm]
    _   = -↑(Int.negSucc n).natAbs := by
            simp [Int.natAbs]

lemma exists_prime_dvd_int
    {z : ℤ} (hz0 : z ≠ 0) (hzpm : z ≠ 1 ∧ z ≠ -1) :
    ∃ p : ℕ, Nat.Prime p ∧ (p : ℤ) ∣ z := by
  classical
  -- Use the nonnegative integer n = |z|
  let n : ℕ := z.natAbs

  -- Step 1: show n ≥ 2
  have hn_ge2 : 2 ≤ n := by
    -- Suppose not, so n < 2
    by_contra hlt
    have hlt' : n < 2 := Nat.lt_of_not_ge hlt
    -- n < 2 ⇒ n ≤ 1
    have hle1 : n ≤ 1 := (Nat.lt_succ_iff).1 hlt'
    -- Rewrite in terms of z.natAbs
    have hzabs_le1 : z.natAbs ≤ 1 := by simpa [n] using hle1

    -- Now show z.natAbs = 0 ∨ 1 from “≤ 1”
    have hzabs_0_or_1 : z.natAbs = 0 ∨ z.natAbs = 1 := by
      -- case split on z.natAbs as a natural
      cases h : z.natAbs with
      | zero =>
          left; norm_cast at h
      | succ k =>
          -- succ k ≤ 1 → k = 0
          have hk_le1 : Nat.succ k ≤ 1 := by simpa [h] using hzabs_le1
          have hk0 : k = 0 := by
            -- succ k ≤ 1 ⇒ k ≤ 0, hence k=0
            have hk0_le : k ≤ 0 :=
              Nat.le_of_succ_le_succ
                (by
                  -- succ k ≤ 1 = succ 0
                  -- So succ k ≤ succ 0
                  have := hk_le1
                  simpa [Nat.choose_zero_succ] using this)
            exact Nat.le_antisymm hk0_le (Nat.zero_le _)
          right
          simp [hk0]

    -- Derive contradiction to hz0 or hzpm
    cases hzabs_0_or_1 with
    | inl hzabs0 =>
        -- |z| = 0 ⇒ z = 0
        have hz_zero : z = 0 := Int.natAbs_eq_zero.1 hzabs0
        exact hz0 hz_zero
    | inr hzabs1 =>
        -- |z| = 1 ⇒ z = ±1
        have hz_pm : z = 1 ∨ z = -1 := (natAbs_eq_one_iff z).1 hzabs1
        cases hz_pm with
        | inl h1 => exact hzpm.1 h1
        | inr hneg1 => exact hzpm.2 hneg1

  -- Step 2: apply the standard ℕ lemma
    -- Only need n ≠ 1 to apply Nat.exists_prime_and_dvd
  have hn_ne1 : n ≠ 1 := by
    intro hn1
    -- n = 1 ⇒ z.natAbs = 1
    have hz_abs1 : z.natAbs = 1 := by
      simpa [n] using hn1
    -- ⇒ z = 1 ∨ z = -1
    have hz_pm : z = 1 ∨ z = -1 :=
      (natAbs_eq_one_iff z).1 hz_abs1
    -- both options contradict hzpm
    cases hz_pm with
    | inl hz1  => exact hzpm.1 hz1
    | inr hz_1 => exact hzpm.2 hz_1

  -- Step 2: apply the standard ℕ lemma with n ≠ 1
  obtain ⟨p, hp_prime, hp_dvd_n⟩ := Nat.exists_prime_and_dvd hn_ne1

  -- Step 3: move divisibility from n = |z| to z itself
  -- Use the standard bridge lemma:
  -- (p : ℤ) ∣ z  ↔  p ∣ z.natAbs
  have hp_dvd_natAbs : p ∣ z.natAbs := by
    -- n = z.natAbs by definition
    simpa [n] using hp_dvd_n

  -- Finally: pass from divisibility of n = natAbs z to divisibility of z.
  have hp_dvd_natAbsZ : (p : ℤ) ∣ (n : ℤ) := by
    exact_mod_cast hp_dvd_n
  have hp_dvd_z : (p : ℤ) ∣ z := by
    have hz_cases : z = (n : ℤ) ∨ z = - (n : ℤ) := by
      -- lemma gives z = z.natAbs ∨ z = - (z.natAbs : ℤ)
      -- so rewrite z.natAbs as n
      simpa [n] using (eq_natAbs_or_neg_natAbs z)

    rcases hz_cases with hz | hz
    · -- Case 1: z = n
      -- rewrite goal to p ∣ (n:ℤ)
      -- and use hp_dvd_natAbsZ directly
      simpa [hz] using hp_dvd_natAbsZ

    · -- Case 2: z = -n
      -- If p ∣ n then p ∣ -n by negating the witness
      rcases hp_dvd_natAbsZ with ⟨k, hk⟩
      refine ⟨-k, ?_⟩
      -- want: z = (p:ℤ) * (-k)
      -- use hz to replace z with -n, then hk to replace n with p*k
      calc
        z = - (n : ℤ) := hz
        _ = - ((p : ℤ) * k) := by simp [hk]
        _ = (p : ℤ) * (-k) := by ring

  -- Done
  exact ⟨p, hp_prime, hp_dvd_z⟩

/-- A prime never divides `±1`. -/
lemma prime_not_dvd_pm_one {p : ℕ} (hp : Nat.Prime p) :
    ¬ (p : ℤ) ∣ (1 : ℤ) ∧ ¬ (p : ℤ) ∣ (-1 : ℤ) := by
  constructor
  · intro h
    -- `p ∣ 1` contradicts `p > 1`
    have : (p : ℕ) ∣ 1 := by
      exact_mod_cast h
    exact hp.not_dvd_one this
  · intro h
    -- `p ∣ -1` ↔ `p ∣ 1`
    have : (p : ℤ) ∣ (1 : ℤ) := by
      simpa using (dvd_neg.mp h)
    have : (p : ℕ) ∣ 1 := by
      exact_mod_cast this
    exact hp.not_dvd_one this


/--
Part 6:
The contradiction argument (topological Furstenberg proof).

Assume finitely many primes.
Let `A` be the union of the multiples of all primes (as subsets of `FbInt`).
Then `A` is closed (finite union of closed sets), hence `Aᶜ` is open.
But `Aᶜ = {±1}`, which is finite and nonempty, contradicting
“every nonempty open set is infinite”.
-/

-- This axiom states: "In a generateFrom topology, if U is a neighborhood of x,
-- then there exists a generating set containing x and contained in U."
axiom generateFrom_mem_nhds_basis {α : Type*} (g : Set (Set α)) (x : α) (U : Set α)
    (hU : U ∈ @nhds α (TopologicalSpace.generateFrom g) x) :
    ∃ V ∈ g, x ∈ V ∧ V ⊆ U

-- **Note: This is left as an axiom for now to focus on the main ideas of the Furstenberg proof.**
-- **This axiom hasn't been proven from Mathlib's existing lemmas.**
-- for further proofs, there is a problem:
  -- The intersection case is genuinely difficult.
  -- For a complete proof, it would be needed to prove that the intersection of two arithmetic progressions is either empty
  -- or another arithmetic progression (Chinese Remainder Theorem),
  -- OR use a different strategy.

-- Show that every nonempty open set in the Furstenberg topology on `FbInt` is infinite.
-- P.S. In lemma open_nonempty_infinite,
  -- it is implicitly assumed that “this holds because furstenbergBasis is a basis”,
  -- which is correct for this specific topology.
lemma open_nonempty_infinite (U : Set FbInt)
    (hU : IsOpenT U) (hne : U ≠ ∅) : U.Infinite := by
  classical
  obtain ⟨x, hx⟩ : Set.Nonempty U := Set.nonempty_iff_ne_empty.mpr hne

  -- Step 1: every basis element arithProgF a b (b > 0) is infinite
  have basis_infinite : ∀ a b, 0 < b → (arithProgF a b).Infinite := by
    intro a b hb
    classical

    -- parametrization ℤ → FbInt
    let f : ℤ → FbInt := fun n => ⟨a + (b : ℤ) * n⟩

    -- 1. show f is injective
    have hinj : Function.Injective f := by
      intro m n h
      -- drop ULift wrapper
      have h' : a + (b : ℤ) * m = a + (b : ℤ) * n := by
        -- (f m).down = (f n).down is the same equality
        -- `congrArg ULift.down h : (f m).down = (f n).down`
        simpa [f] using congrArg ULift.down h
      -- cancel `a` and then cancel nonzero `(b : ℤ)`
      have hb0 : (b : ℤ) ≠ 0 := by
        exact_mod_cast (Nat.ne_of_gt hb)
      have h'' : (b : ℤ) * m = (b : ℤ) * n := by
        -- a + b*m = a + b*n ⇒ b*m = b*n
        exact add_left_cancel h'
      exact mul_left_cancel₀ hb0 h''

    -- 2. range f ⊆ the arithmetic progression in FbInt
    have hsubset : Set.range f ⊆ arithProgF a b := by
      intro x hx
      rcases hx with ⟨n, rfl⟩
      -- goal: f n ∈ arithProgF a b

      -- build the congruence on ℤ
      have hmod : Int.ModEq (b : ℤ) (a + (b : ℤ) * n) a := by
        apply (Int.modEq_iff_dvd).2
        refine ⟨-n, ?_⟩
        ring

      -- unfold membership in `arithProgF` and `(f n).down`
      change Int.ModEq (b : ℤ) (a + (b : ℤ) * n) a
      exact hmod

    -- 3. range of injective f : ℤ → FbInt is infinite
    have h_range_inf : (Set.range f).Infinite :=
      Set.infinite_range_of_injective hinj

    -- 4. any superset of an infinite set is infinite
    exact h_range_inf.mono hsubset

  -- Step 2: use the neighborhood basis axiom to find a basis element inside U,
  -- then use basis_infinite and monotonicity.
  have hU_nhds : U ∈ @nhds FbInt furstenbergTopology x :=
    IsOpen.mem_nhds (by simpa [IsOpenT] using hU) hx
  unfold furstenbergTopology at hU_nhds

  obtain ⟨B, hB_basis, hxB, hB_sub⟩ :=
    generateFrom_mem_nhds_basis furstenbergBasis x U hU_nhds

  -- B is a basis element, hence B = arithProgF a b for some a, b, 0 < b
  obtain ⟨a, b, hb, rfl⟩ := hB_basis

  -- arithProgF a b is infinite and contained in U, so U is infinite
  exact (basis_infinite a b hb).mono hB_sub

-- Final theorem: there are infinitely many primes.
-- Proof by contradiction using the Furstenberg topology on FbInt.
theorem infinite_primes
    (hfin : Set.Finite {p : ℕ | Nat.Prime p}) : False := by
  classical

  -- Turn the finite set of primes into a finite index type.
  let ι : Type := {p : ℕ // p ∈ hfin.toFinset}
  haveI : Fintype ι := by
    classical
    exact Fintype.ofFinite ι

    -- Union of multiples of all primes in the finite list
  let A : Set FbInt := ⋃ p : ι, multiplesF p.1

  -- Each `multiplesF p` is closed, so the finite union is closed.
  have hA_closed : IsClosed A := by
    classical
    -- first, closedness of each piece
    have h_cl : ∀ p : ι, IsClosed (multiplesF p.1) := by
      intro p
      have hp_mem : p.1 ∈ hfin.toFinset := p.2
      have hp_prime : Nat.Prime p.1 := by
        -- key bridge: membership in the finset of primes
        have : p.1 ∈ ({q : ℕ | Nat.Prime q} : Set ℕ) := by
          simpa [hfin.mem_toFinset] using hp_mem
        simpa using this
      -- from clopen, take the closed half
      have hClosedT : IsClosedT (multiplesF p.1) :=
        (multiples_prime_clopen (p := p.1) hp_prime).2
      -- `IsClosedT U` ↔ `IsClosed U`
      exact (IsClosedT_iff_IsClosed (U := multiplesF p.1)).1 hClosedT

    -- now use the finite-union lemma
    have : IsClosed (⋃ p : ι, multiplesF p.1) :=
      isClosed_iUnion_of_finite h_cl
    simpa [A] using this

  -- Therefore `Aᶜ` is open
  have hA_open : IsOpenT (Aᶜ) :=
    (isOpen_compl_iff.mpr hA_closed)

  -- Main arithmetic fact: complement of union of prime multiples is `{±1}`.
  have hA_compl_eq_pm1 :
      Aᶜ = ({(⟨(1 : ℤ)⟩ : FbInt), (⟨(-1 : ℤ)⟩ : FbInt)} : Set FbInt) := by
    classical
    ext x
    constructor

    · intro hx
      -- hx : x ∈ Aᶜ, so x ∉ A
      have hxA : x ∉ A := by
        simpa [Set.mem_compl] using hx
      -- open x as ULift ℤ
      cases x with
      | up z =>
        -- Now the element is explicitly ⟨z⟩ : FbInt
        -- and hxA : (⟨z⟩ : FbInt) ∉ A (by rewriting).
        have hxA' : (⟨z⟩ : FbInt) ∉ A := by
          simpa using hxA

        -- Case 1: z = 1
        by_cases hz1 : z = 1
        · -- then ⟨z⟩ = ⟨1⟩
          have hz_eq : (⟨z⟩ : FbInt) = ⟨(1 : ℤ)⟩ := by
            simp [hz1]
          -- membership in {⟨1⟩,⟨-1⟩} via the left injection
          left
          exact hz_eq

        -- Case 2: z = -1
        by_cases hzn1 : z = -1
        · have hz_eq : (⟨z⟩ : FbInt) = ⟨(-1 : ℤ)⟩ := by
            simp [hzn1]
          right
          exact hz_eq

        -- From here: z ≠ 0, 1, -1.
        have hz0 : z ≠ 0 := by
          intro hz0
          -- 2 is prime and in the finite set of all primes
          have hp2 : Nat.Prime 2 := by decide
          have hmem2 : (2 : ℕ) ∈ hfin.toFinset :=
            hfin.mem_toFinset.2 hp2
          -- show ⟨z⟩ ∈ A
          have hxA'' : (⟨z⟩ : FbInt) ∈ A := by
            refine Set.mem_iUnion.2 ⟨⟨2, hmem2⟩, ?_⟩
            -- goal: ⟨z⟩ ∈ multiplesF 2
            -- i.e. (2 : ℤ) ∣ z; use z = 0
            simp [multiplesF, hz0]
            -- 2 ∣ 0
            exact dvd_zero 2
          exact hxA' hxA''

        -- arithmetic lemma: a prime divides z
        rcases exists_prime_dvd_int (z := z) hz0 ⟨hz1, hzn1⟩ with ⟨p, hp, hpdvd⟩
        have hmemP : p ∈ hfin.toFinset := hfin.mem_toFinset.2 hp
        -- Then ⟨z⟩ is in the union A
        have hxA'' : (⟨z⟩ : FbInt) ∈ A := by
          refine Set.mem_iUnion.2 ⟨⟨p, hmemP⟩, ?_⟩
          -- goal: ⟨z⟩ ∈ multiplesF p  ⇔  (p : ℤ) ∣ z
          simpa [multiplesF] using hpdvd
        exact (hxA' hxA'').elim

    · intro hx hxA
      -- hx : x ∈ {±1}; want x ∈ Aᶜ, i.e. x ∉ A
      rcases (Set.mem_insert_iff.mp hx) with hx1 | hxrest
      · -- Case x = 1
        subst hx1
        rcases Set.mem_iUnion.1 hxA with ⟨p, hpMul⟩
        have hpPrime : Nat.Prime p.1 := by
          have hp_mem : p.1 ∈ hfin.toFinset := p.2
          have : p.1 ∈ ({q : ℕ | Nat.Prime q} : Set ℕ) := by
            simpa [hfin.mem_toFinset] using hp_mem
          simpa using this
        have hnot : ¬ (p.1 : ℤ) ∣ (1 : ℤ) :=
          (prime_not_dvd_pm_one hpPrime).1
        have hdiv : (p.1 : ℤ) ∣ (1 : ℤ) := by
          simpa [multiplesF] using hpMul
        exact (hnot hdiv).elim

      · -- Case x = -1
        have hxneg1 : x = (⟨(-1 : ℤ)⟩ : FbInt) := by
          simpa [Set.mem_singleton_iff] using hxrest
        subst hxneg1
        rcases Set.mem_iUnion.1 hxA with ⟨p, hpMul⟩
        have hpPrime : Nat.Prime p.1 := by
          have hp_mem : p.1 ∈ hfin.toFinset := p.2
          have : p.1 ∈ ({q : ℕ | Nat.Prime q} : Set ℕ) := by
            simpa [hfin.mem_toFinset] using hp_mem
          simpa using this
        have hnot : ¬ (p.1 : ℤ) ∣ (-1 : ℤ) :=
          (prime_not_dvd_pm_one hpPrime).2
        have hdiv : (p.1 : ℤ) ∣ (-1 : ℤ) := by
          simpa [multiplesF] using hpMul
        exact (hnot hdiv).elim

  -- So `{±1}` is open.
  have hopen_pm1 :
      IsOpenT ({(⟨(1 : ℤ)⟩ : FbInt), (⟨(-1 : ℤ)⟩ : FbInt)} : Set FbInt) := by
    simpa [hA_compl_eq_pm1] using hA_open

  -- `{±1}` is finite and nonempty.
  have hfinite_pm1 :
      ({(⟨(1 : ℤ)⟩ : FbInt), (⟨(-1 : ℤ)⟩ : FbInt)} : Set FbInt).Finite := by
    simp
  have hnonempty_pm1 :
      ¬ ({({down := (1 : ℤ)} : FbInt), ({down := (-1 : ℤ)} : FbInt)} : Set FbInt) = ∅ := by
    intro h
    have hx : ({down := (1 : ℤ)} : FbInt) ∈
      ({({down := (1 : ℤ)} : FbInt), ({down := (-1 : ℤ)} : FbInt)} : Set FbInt) := by
      simp
    rw [h] at hx
    exact hx

  -- key topology lemma: any nonempty open set is infinite.
  have h_open_infinite :
      ∀ U : Set FbInt, IsOpenT U → U ≠ ∅ → U.Infinite := by
    intro U hU hne
    exact open_nonempty_infinite U hU hne

  have : ({(⟨(1 : ℤ)⟩ : FbInt), (⟨(-1 : ℤ)⟩ : FbInt)} : Set FbInt).Infinite :=
    h_open_infinite _ hopen_pm1 hnonempty_pm1

  exact hfinite_pm1.not_infinite this

end Furstenberg
